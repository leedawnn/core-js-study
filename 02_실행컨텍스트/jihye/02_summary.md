# 02_실행 컨텍스트

## 01_실행 컨텍스트란?
**실행할 코드에 제공할 환경 정보들을 모아놓은 객체**

스택(stack)과 큐(queue)의 개념
```
스택: 출입구가 하나뿐인 깊은 우물 같은 데이터 구조
(순서대로 데이터 a, b, c, d를 저장했다면, 꺼낼 땐 반대로 d, c, b, a의 순서로 꺼낼 수 밖에 없다.)

큐: 양쪽이 모두 열려있는 파이프같은 데이터 구조 
(보통 한쪽은 입력만, 다른 한쪽은 출력만을 담당. 이 경우에는 큐에 순서대로 데이터 a, b, c, d를 저장했다면 꺼낼 때도 역시 a, b, c, d의 순서로 꺼낼 수밖에 없다)
```

자동으로 생성되는 전역공간과 eval을 제외하면 우리가 흔히 실행 컨텍스트를 구성하는 방법은 **함수를 실행**하는 방법 뿐이다.

처음 자바스크립트 코드를 실행하는 순간, 전역 컨텍스트가 콜 스택에 담긴다. (여기서 전역 컨텍스트라는 개념은 일반적인 실행 컨텍스트와 특별히 다를 것이 없다.) 최상단의 공간은 코드 내부에서 별도의 실행 명령이 없이도 브라우저에서 자동으로 실행하므로 자바스크립트 파일이 열리는 순간 전역 컨텍스트가 활성화된다고 이해하면 된다. 

콜 스택에 전역 컨텍스트 외에 다른 덩어리가 없으므로 전역 컨텍스트와 관련된 코드들을 순차로 진행하다가 outer 함수를 호출하면 자바스크립트 엔진은 outer에 대한 환경 정보를 수집해서 outer 실행 컨텍스트를 생성한 후 콜 스택에 담는다. 따라서 콜 스택의 맨 위에 outer 실행 컨텍스트가 놓인 상태가 됐으므로 전역 컨텍스트와 관련된 코드의 실행을 일시중단하고 대신 outer 실행 컨텍스트와 관련된 코드, **즉 outer 함수 내부의 코드들을 순차로 실행한다.**

=> 만약 이 위에 inner 함수의 실행 컨텍스트가 위에 담기면? 똑같이 outer 컨텍스트와 관련된 코드의 실행을 중단하고 inner 함수 내부의 코드를 순서대로 진행!

inner 함수 내부에서 a 변수에 값 3을 할당하고 나며 inner 함수의 실행이 종료되면서 inner 실행 컨텍스트가 콜 스택에서 제거된다. 그러면 아래에 있는 outer 컨텍스트가 맨 위에 존재하게 되므로 중단했던 다음 줄부터 이어서 실행한다. 이런 로직을 반복하여 전역 공간에 더는 실행할 코드가 남아 있지 않아 전역 컨텍스트도 제거되고, 콜 스택에는 아무것도 남지 않은 상태로 종료된다. 

스택 구조를 잘 생각해보면, 하나의 실행 컨텍스트가 콜 스택의 맨 위에 쌓이는 순간이 곧 현재 실행할 코드에 관여하게 되는 시점임을 알 수 있다. 이렇게 어떤 실행 컨텍스트가 활성화될 때 자바스크립트 엔진은 해당 컨텍스트에 관련된 코드들을 실행하는 데 필요한 환경 정보들을 수집해서 실행 컨텍스트 객체에 저장한다. 이 객체는 자바스크립트 엔진이 활용할 목적으로 생성할 뿐 개발자가 코드를 통해 확인할 수는 없다. 여기에 담기는 정보는 다음과 같다.
```
variableEvironment: 현재 컨텍스트 내의 식별자들에 대한 정보 + 외부 환경 정보. 선언 시점의 LexicalEnvironment의 스냅샷으로, 변경 사항은 반영되지 않음.

LexicalEnvironment: 처음에는 VariableEnvironment와 같지만 변경 사항이 실시간으로 반영됨.

ThisBinding: this 식별자가 바라봐야 할 대상 객체.
```

## 02_VariableEnvironment

VariableEvironment에 담기는 내용은 LexicalEnvironment와 같지만 최초 실행 시의 스냅샷을 유지한다는 점이 다르다. 실행 컨텍스트 생성시 VariableEvironment에 정보를 먼저 담은 후, 이를 그대로 복사해서 LexicalEnvironment를 만들고, 이후에는 LexicalEnvironment를 주로 활용한다.

VariableEvironment와 LexicalEnvironment의 내부는 EnvironmentReference로 구성돼 있다. 초기화 과정 중에는 사실상 완전히 동일하고 이후 코드 진행에 따라 서로 달라진다.

## 03_LexicalEnvironment
"현재 컨텍스트의 내부에는 a, b, c와 같은 식별자들이 있고 그 외부 정보는 D를 참조하도록 구성돼 있다."라는, 컨텍스트를 구성하는 환경 정보들을 사전에서 접하는 느낌으로 모아놓은 것이다. 

### 2-3-1 environmentRecord와 호이스팅
environmentRecord는 현재 컨텍스트와 관련된 코드의 식별자 정보들이 저장된다. 컨텍스트 내부 전체를 처음부터 끝까지 쭉 훑어나가며 **순서대로** 수집한다. 변수 정보를 수집하는 과정을 모두 마쳤더라도 실행 컨텍스트가 관여할 코드들은 실행되기 전의 상태이다. 코드가 실행되기 전임에도 불구하고 자바스크립트 엔진은 이미 해당 환경에 속한 코드의 변수명들을 모두 알고 있게 되는 셈이다. 그렇다면 엔진의 실제 동작 방식 대신에 '자바스크립트 엔진은 식별자들을 최상단으로 끌어올려놓은 다음 실제 코드를 실행한다'라고 생각하더라도 코드를 해석하는 데는 문제될 것이 전혀 없을 것이다. 여기서 호이스팅이라는 개념이 등장한다.

#### 호이스팅 규칙
```
호이스팅이란?
어디에 선언했냐에 상관없이 항상 제일 위로 선언을 끌어올려주는 것.
즉, 스코프 내부 어디서든 변수 선언은 최상위에 선언된 것처럼 행동하는 것이다. 

ex) var는 선언하기 전에 사용할 수 있다.
var name;
console.log(name); // undefined
name = 'Mike';
```
var로 선언한 모든 변수는 코드가 실제로 이동하지는 않지만, 최상위로 끌어올려진 것처럼 동작합니다. 위의 예시에서는 선언은 호이스팅 되지만, 할당은 호이스팅 되지 않기에 undefined라고 콘솔에 찍힌다. 즉 name이라는 변수만 올려진 것이고 mike라는 변수는 그 자리게 있는 것이다.  
```
console.log(name); // ReferenceError
let name = 'Mike';
```
그런데 왜 let은 var처럼 동작하지 않고 에러를 내는 것일까? 바로 TDZ(Temporal Dead Zone)때문이다. let과 const는 TDZ의 영향을 받는다. 할당을 하기 전에는 사용할 수 없으며, 이는 코드를 예측가능하게 하고 잠재적인 버그를 줄인다.
```
console.log(name) // Temporal Dead Zone
const name = "Mike" // 함수 선언 및 할당
console.log(name) // 사용 가능
```

#### 함수 선언문과 함수 표현식
함수 선언문과 함수 표현식은 둘 모두 함수를 새롭게 정의할 때 쓰이는 방식이다. 그중 함수 선언문은 funciton 정의부만 존재하고 별도의 할당 명령이 없는 것을 의미하고, 반대로 함수 표현식은 정의한 function을 별도의 변수에 할당하는 것을 말한다. 함수 선언문의 경우 반드시 함수명이 정의돼 있어야 하는 반면, 함수 표현식은 없어도 된다. 함수명을 정의한 함수 표현식을 '기명 함수 표현식', 정의하지 않은 것을 '익명 함수 표현식'이라고 부르기도 하는데, 일반적으로 함수 표현식은 익명 함수 표현식을 말한다. 
```
function a () {/*...*/} // 함수 선언문. 함수명 a가 곧 변수명
a(); // 실행 OK

var b = function () {/*...*/} // (익명) 함수 표현식. 변수명 b가 곧 함수명.
b(); // 실행 OK

var c = function d () {/*...*/} // 기명 함수 표현식. 변수명은 c, 함수명은 d.
c(); // 실행 OK.
d(); // 에러!
```

**그렇다면 함수 선언문과 함수 표현식의 실질적인 차이는??**
함수 선언문은 전체를 호이스팅한 반면 함수 표현식은 변수 선언부만 호이스팅을 했다. 함수도 하나의 값으로 취급할 수 있다는 것이 바로 이런 것이다. 함수를 다른 변수에 값으로써 '할당'한 것이 곹 함수 표현식이다. 여기서 함수 선언문과 함수 표현식의 극적인 차이가 발생한다. 

만약 동일한 변수명에 서로 다른 값을 할당할 경우 나중에 할당한 값이 먼저 할당한 값을 덮어씌운다. 따라서 코드를 실행하는 중에 실제로 호출되는 함수는 오직 마지막에 할당한 함수, 즉 맨 마지막에 선언된 함수뿐이다. 

개발 시 원활한 협업을 위해서는 전역공간에 함수를 선언하거나 동명의 함수를 중복 선언하는 경우는 없어야 한다. 그러나 만에 하나 전역공간에 동명의 함수가 여럿 존재하는 상황이라 하더라도 모든 함수가 함수 표현시긍로 정의돼 있었다면, 어떤 코드가 문제인지 찾을 수 없는 상황은 일어나지 않았을 것이다. 

**상대적으로 함수 표현식이 개발 시 안전하다!!**

### 2-3-2 스코프, 스코프 체인, outerEnvironmentReference
스코프란 식별자에 대한 유효범위이다. 어떤 경계 A의 외부에서 선언한 변수는 A의 외부뿐 아니라 A의 내부에서도 접근이 가능하지만, A의 내부에서 선언한 변수는 오직 A의 내부에서만 접근할 수 있다. 다만 ES5까지의 자바스크립트는 특이하게도 전역공간을 제외하면 **오직 함수에 의해서만** 스코프가 생성된다. 어쨌든 이러한 '식별자의 유효범위'를 안에서부터 바깥으로 차례로 검색해나가는 것을 스코프체인이라고 한다. 그리고 이를 가능케 하는 것이 바로 LexicalEnvironment의 두 번째 수집 자료인 outerEnvironmentReference이다.

#### 스코프 체인
outerEnvironmentReference는 현재 호출된 함수가 **선언될 당시**의 LexicalEnvironment를 참조한다. 과거 시점인 '선언될 당시'에 주목해보자. '선언하다'라는 행위가 실제로 일어날 수 있는 시점이란 콜 스택 상에서 어떤 실행 컨텍스트가 활성화된 상태이다. 어떤 함수를 선언(정의)하는 행위 자체도 하나의 코드에 지나지 않으며, 모든 코드는 실행 컨텍스트가 활성화 상태일 때 진행되기 때문이다.

예를 들어, A 함수 내부에 B 함수를 선언하고 다시 B 함수 내부에 C 함수를 선언한 경우, 함수 C의 outerEnvironmentReference는 함수 B의 LexicalEnvironment를 참조한다. 함수 B의 LexicalEnvironment는 함수 B의 outerEnvironmentReference는 다시 함수 B가 선언되던 때의 LexicalEnvironment를 참조한다. 이처럼 outerEnvironmentReference 연결리스트 형태를 띈다. 또한 각 outerEnvironmentReference는 오직 자신이 선언된 시점의 LexicalEnvironment만 참조하고 있으므로 가장 가까운 요소부터 차례대로만 접근할 수 있고 다른 순서로 접근하는 것은 불가능하다. 이런 구조적 특성 덕분에 여러 스코프에서 동일한 식별자를 선언한 경우에는 **무조건 스코프 체인 상에서 가장 먼저 발견된 식별자에만 접근 가능**하게 된다.
```
var a = 1;
var outer = function () {
    var inner = function () {
        console.log(a)
        var a = 3
    };
    inner();
    console.log(a)
};
outer()
console.log(a)
```
표 2-1의 전체 윤곽을 왼쪽에서 오른쪽으로 바라보면 '전역 컨텍스트 -> outer 컨텍스트 -> inner 컨텍스트' 순으로 점차 규모가 작아지는 반면 스코프 체인을 타고 접근 가능한 변수의 수는 늘어난다. (ex. A의 내부에서 선언한 변수는 오직 A의 내부에서만 접근가능하기에. 안쪽에서부터 바깥으로 차례를 검색해나가는 것이 스코프 체인.)
- 전역공간: 전역 스코프에서 생성된 변수에만 접근가능
- outer 함수 내부: outer 및 전역 스코프에서 생성된 변수에 접근할 수 있지만 inner 스코프 내부에서 생성된 변수에는 접근 x
- inner 함수 내부: inner, outer, 전역 스코프 모두에 접근가능

한편 스코프 체인 상에 있는 변수ㅠ라고 해서 무조건 접근 가능한 것은 아니다. inner 함수 내부에서 a에 접근하려고 하면 스코프 체인 상의 첫 번째 인자, 즉 inner 스코프의 LexicalEnvironment부터 검색할 수밖에 없다. inner스코프의 LexicalEnvironment에 a 식별자가 존재하므로 스코프 체인 검색을 더 진행하지 않고 즉시 inner LexicalEnvironment 상의 a를 반환하게 된다. 즉, inner 함수 내부에서 a 변수를 선언했기 때문에 전역 공간에서 선언한 동일한 이름의 a 변수에는 접근할 수 없는 셈이다. 이를 **변수 은닉화**라고 한다.

#### 전역변수와 지역변수
전역 공간에서 선언한 변수는 전역변수이고, 함수 내부에서 선언한 변수는 무조건 지역변수이다.

## 04_this
실행 컨텍스트의 thisBing에는 this로 지정된 객체가 저장된다. 실행 컨텍스트 활성화 당시에 this가 지정되지 않은 경우 this에는 전역 객체가 저장된다. 그밖에는 함수를 호출하는 방식에 따라 this에 저장되는 대상이 다르다. 

## 05_정리
```
실행 컨텍스트: 실행할 코드에 제공할 환경 정보들을 모아놓은 객체.
```
실행 컨텍스트는 전역 공간에서 자동으로 생성되는 전역 컨텍스트와 eval 및 함수 실행에 의한 컨텍스트 등이 있다. 실행 컨텍스트 객체는 활성화되는 시점에 VariableEnvironment, LexialEnvironment, ThisBinding 세 가지 정보를 수집한다.

```
VariableEnvironment와 LexicalEnvironment의 공통점: 동일한 내용으로 구성
VariableEnvironment: 초기 상태를 유지
LexicalEnvironment: 함수 실행 도중에 변경되는 사항이 즉시 반영, environmentRecord와 outerEnvironmentReference로 구성.
environmentRecord: 매개변수명, 변수의 식별자, 선언한 함수의 함수명 등을 수집
outerEnvironmentReference: 바로 직전 컨텍스트의 LexicalEnvironment 정보를 참조
```
VariableEnvironment와 LexicalEnvironment가 동일한 내용으로 구성되지만 LexicalEnvironment는 함수 실행 도중에 변경되는 사항이 즉시 반영되는 반면 VariableEnvironment는 초기 상태를 유지. VariableEnvironment와 LexicalEnvironment는 매개변수명, 변수의 식별자, 선언한 함수의 함수명 등을 수집하는 environmentRecord와 바로 직전 컨텍스트의 LexicalEnvironment 정보를 참조하는 outerEnvironmentReference로 구성돼 있다. 

호이스팅은 코드 해석을 좀 더 수월하게 하기 위해 environmentRecord의 수집 과정을 추상화한 개념으로, 실행 컨텍스트가 관여하는 코드 집단의 최상단으로 이들을 '끌어올린다'고 해석한다. 변수 선언과 값 할다이 동시에 이뤄진 문장은 '선언부'만을 호이스팅하고, 할당 과정은 원래 자리에 남아있게 되는데, 여기서 함수 선언문과 함수 표현식의 차이가 발생

스코프는 변수의 유효범위를 말한다. 

전역 컨텍스트의 LexicalEnvironment에 담긴 변수를 전역변수라 하고, 그 밖의 함수에 의해 생성된 실행 컨텍스트의 변수들은 모두 지역변수이다. 안전한 코드 구성을 위해 전역변수의 사용은 최소화하는 것이 좋다.

this에는 실행 컨텍스트를 활성화하는 당시에 지정된 this가 저장된다. 함수를 호출하는 방법에 따라 그 값이 달라지는데, 지정되지 않은 경우에는 전역 객체가 저장된다...!

