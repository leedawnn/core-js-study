# 실행 컨텍스트

2장 목표 : 실행 컨텍스트의 개념을 파악하고 어떤 구성을 가지고 있는지 알아본다. 그리고 호이스팅과 외부 환경 정보를 어떻게 구성하는지 this 값을 설정하는 등의 동작에 대해 알아본다.

## 실행 컨텍스트란?

실행 컨텍스트는 **실행할 코드에 제공할 환경 정보들을 모아놓은 객체**이다.

**동일한 환경**에 있는 코드들을 실행할 때 필요한 환경 정보들을 모아 컨텍스트를 구성하고, 이를 콜 스택에 쌓아올렸다가, 가장 위에 쌓여있는 컨텍스트와 관련 있는 코드들을 실행하는 식으로 전체 코드의 환경과 순서를 보장한다.

여기서, '동일한 환경' 즉 하나의 실행 컨텍스트를 구성할 수 있는 방법으로 전역 공간, eval() 함수, 함수 등이 있다. 자동으로 생성되는 전역공간과 eval을 제외하면 **우리가 흔히 실행 컨텍스트를 구성하는 방법은 함수를 실행**하는 것 뿐이다.

#### 콜 스택에 실행 컨텍스트는 어떤 순서로 쌓이고, 어떤 순서로 코드 실행에 관여할까?

```javascript
// -------------------------- (1)
var a = 1;
function outer() {
  function inner() {
    console.log(a); // undefined
    var a = 3;
  }
  inner(); // --------------- (2)
  console.log(a); // 1
}
outer(); // ----------------- (3)
console.log(a) // 1
```

위의 코드와 같이 처음 자바스크립트 코드를 실행하는 순간(1) 전역 컨텍스트가 콜 스택에 담긴다. (자바스크립트 파일이 열리는 순간 전역 컨텍스트가 활성화된다고 이해하면 됨.)

그 다음 (3)에서 outer 함수를 호출하면 자바스크립트 엔진은 outer에 대한 환경 정보를 수집해서 outer 실행 컨텍스트를 생성한 후 콜 스택에 담는다. 이제 콜 스택 맨 위에 outer 실행 컨텍스트가 놓인 상태가 됐으므로 전역 컨텍스트와 관련된 코드의 실행을 일시중단하고 outer 함수 내부의 코드들을 순차로 실행한다.

다시 (2)에서 inner 함수의 실행 컨텍스트가 콜 스택의 가장 위에 담기면 outer 컨텍스트와 관련된 코드의 실행을 중단하고 inner 함수 내부의 코드를 순서대로 진행한다. 이제 a 변수에 3을 할당하고 나면 inner 함수의 실행이 종료되면서 inner 실행 컨텍스트가 콜 스택에서 제거된다.

그러면 아래에 있던 outer 컨텍스트가 콜 스택의 맨 위에 존재하게 되므로 중단했던 (2)의 다음 줄부터 이어서 실행한다. a 변수의 값을 출력하고 나면 outer 함수의 실행이 종료되어 outer 실행 컨텍스트가 콜 스택에서 제거되고, 콜 스택에는 전역 컨텍스트만 남아 있게 된다. 그런 다음, 실행을 중단했던 (3)의 다음 줄부터 이어서 실행하고 a 변수를 출력하고 나면 전역 공간에 실행할 코드가 남아있지 않아 전역 컨텍스트도 제거되어 콜 스택에는 아무것도 남지 않은 상태로 종료된다.

**실행 컨텍스트가 콜 스택의 맨 위에 쌓이는 순간이 곧 현재 실행할 코드에 관여하게 되는 시점임을 알 수 있다.** 이렇게 어떤 실행 컨텍스트가 활성화될 때 자바스크립트 엔진은 해당 컨텍스트에 관련된 코드들을 실행하는 데 필요한 환경 정보들을 수집해서 실행 컨텍스트 객체에 저장한다.

실행 컨텍스트 객체에 담기는 정보들은 다음과 같다.

- **VariableEnvironment** : 현재 컨텍스트 내의 식별자들에 대한 정보 + 외부 환경 정보. 선언 시점의 LexicalEnvironment의 스냅샷으로, 변경 사항은 반영되지 않음.
- **LexicalEnvironment** : 처음에는 VariableEnvironment와 같지만 변경 사항이 실시간으로 반영됨.
- **ThisBinding** : this 식별자가 바라봐야 할 대상 객체.

## VariableEnvironment

VariableEnvironment에 담기는 내용은 LexicalEnvironment와 같지만 최초 실행 시의 스냅샷을 유지한다는 점이 다르다. 실행 컨텍스트를 생성할 때 VariableEnvironment에 정보를 먼저 담은 다음, 이를 그대로 복사해서 LexicalEnvironment를 만들고, 이후에는 LexicalEnvironment를 주로 활용하게 된다.

VariableEnvironment와 LexicalEnvironment의 내부는 다음과 같이 구성되어있다.

- environmentRecord
- outer-Environment

초기화 과정 중에는 완전히 동일하고 이후 코드 진행에 따라 서로 달라지게 된다.

## LexicalEnvironment

lexical environment에 대한 한국어 번역은 문서마다 다르다. 이 책에서는 '사전적인'이라는 표현이 가장 어울린다고 설명한다. 즉 "현재 컨텍스트의 내부에는 a, b, c와 같은 식별자들이 있고 그 외부 정보는 D를 참조하도록 구성되어있다."라는, 컨텍스트를 구성하는 환경 정보들을 사전에서 접하는 느낌으로 모아놓은 것이라고 이해하면 된다.

### 2-3-1 | environmentRecord와 호이스팅

environmentRecord에는 현재 컨텍스트와 관련된 코드의 식별자 정보들(매개변수의 이름, 함수 선언, 변수명 등)이 저장된다. 컨텍스트 내부 전체를 처음부터 끝까지 쭉 훑어나가며 **순서대로** 수집한다. (진짜 수집만 함. 실행은 이후에)

따라서 코드가 실행되기 전임에도 불구하고 자바스크립트 엔진은 이미 해당 환경에 속한 코드의 변수명들을 모두 알고 있게 되는 셈이다. 여기서 **호이스팅**이라는 개념이 등장한다.

>**호이스팅** : 코드가 실행되기 전 변수 정보를 수집하는 과정

#### 호이스팅 규칙

environmentRecord는 현재 실행될 컨텍스트의 대상 코드 내에 어떤 식별자들이 있는지에만 관심이 있고, 각 식별자에 어떤 값이 할당될 것인지는 관심이 없다. 따라서 변수를 호이스팅할 때 변수명만 끌어올리고 할당 과정은 원래 자리에 그대로 남겨둔다. 매개변수도 마찬가지이다.

```javascript
function a() {
  console.log(b);  // (1)
  var b = 'bbb';   // 수집 대상1(변수 선언)
  console.log(b);  // (2)
  function b() { } // 수집 대상2(함수 선언)
  console.log(b);  // (3)
}
a();
```

a 함수를 실행하는 순간 a 함수의 실행 컨텍스트가 생성된다. 이때 변수명과 함수 선언의 정보를 위로 끌어올린다(수집한다). 변수는 선언부와 할당부를 나누어 선언부만 끌어올리는 반면 함수 선언은 함수 전체를 끌어올린다. 호이스팅이 끝난 상태에서의 함수 선언문은 함수명으로 선언한 변수에 함수를 할당한 것처럼 여길 수 있다. 이제 해석을 위해 코드를 바꿔보자.

```javascript
function a() {
  var b;
  var b = function b() { }

  console.log(b); // 함수 b
  var b = 'bbb';
  console.log(b); // 'bbb'
  console.log(b); // 'bbb'
}
a();
```

#### 함수 선언문과 함수 표현식

둘 모두 함수를 새롭게 정의할 때 쓰이는 방식인데, 그 중 **함수 선언문**은 function 정의부만 존재하고 별도의 할당 명령이 없는 것을 의미하고, 반대로 **함수 표현식**은 정의한 function을 별도의 변수에 할당하는 것을 말한다.

즉, 함수 선언문의 경우 반드시 함수명이 정의되어야하는 반면, 함수 표현식은 없어도 된다. 일반적으로 함수 표현식은 익명 함수 표현식을 말한다.

```javascript
function a() { /* ... */ } // 함수 선언문. 함수명 a가 곧 변수명.
a();

var b = function() { /* ... */ } // (익명) 함수 표현식. 변수명 b가 곧 함수명.
b();

var c = function d() { /* ... */ } // 기명 함수 표현식. 변수명은 c, 함수명은 d.
c(); // 잘 실행됨.
d(); // 에러!
```

함수 선언문과 함수 표현식의 실질적인 차이를 알아보자.

```javascript
console.log(sum(1, 2));
console.log(multiply(3, 4));

function sum(a, b) {             // 함수 선언문 sum : 함수 전체를 호이스팅
  return a + b;
}

var mutiply = function (a, b) {  // 함수 표현식 multiply : 변수는 선언부만 호이스팅
  return a * b;
}
```

함수 선언문은 전체를 호이스팅한 반면 함수 표현식은 변수 선언부만 호이스팅했다. 함수도 하나의 값으로 취급할 수 있다는 것이 바로 이런 것이다.

호이스팅이 끝났으니 내부의 코드들을 차례대로 실행해보자.

sum 함수는 선언 전에 호출해도 아무 문제 없이 실행된다. 여기에서 함수 선언문의 위험성이 드러난다. 실무에서 발생할 수 있는 현실적인 예를 하나 들어보자.

개발자 A가 sum 함수를 선언했다. 인자 두 개를 받아 두 인자의 합을 반환하는 단순한 함수다. 이 함수는 100번째 줄에 위치한다고 해보자. 근데 어느날 새로 입사한 B가 같은 파일의 5000번째 줄에서 sum 함수를 새로 선언한다. x, y를 받아 가독성 좋게 문자열로 `"x + y = (x+y)"`를 반환하는 함수이다. B는 본인이 작성한 sum 함수가 5000번째 줄 이후에만 영향을 줄 것이라고 굳게 믿고 테스트 없이 commit, merge한 다음 배포까지 해버린다면 ^^....?

**전역 컨텍스트가 활성화될 때 전역공간에 선언된 함수들이 모두 가장 위로 끌어올려진다. 동일한 변수명에 서로 다른 값을 할당할 경우 나중에 할당한 값이 먼저 할당한 값을 덮어씌운다(override).**

만약 A와 B 모두 sum 함수를 함수 표현식으로 정의했다면 5000번째 줄 이전까지는 A의 의도대로, 5000번째 줄 이후부터는 B의 의도대로 잘 동작했을 것이다.

### 2-3-2 | 스코프, 스코프 체인, outerEnvironmentReference

**스코프(scope)란 식별자에 대한 유효범위이다.** ES5까지의 자바스크립트는 특이하게도 전역공간을 제외하면 **오직 함수에 의해서만** 스코프가 생성된다.

> ES6에서는 블록에 의해서도 스코프 경계가 발생하게 함으로써 다른 언어와 훨씬 비슷해졌다. 다만 이러한 블록은 var로 선언한 변수에 대해서는 작용하지 않고, let과 const, class, strict mode에서의 함수 선언 등에 대해서만 범위로서의 역할을 수행한다. ES6에서는 둘을 구분하기 위해 함수 스코프, 블록 스코프라는 용어를 사용한다.

이러한 **'식별자의 유효범위'를 안에서부터 바깥으로 차례로 검색해나가는 것을 스코프 체인(scope chain)**이라고 한다. 그리고 이를 가능케 하는 것이 바로 LexicalEnvironment의 두번째 수집 자료인 **outerEnvironmentReference**이다.

#### 스코프 체인

outerEnvironmentReference는 현재 호출된 함수가 선언될 당시의 LexicalEnvironment를 참조한다. '선언될 당시'라는 말에 주목해야하는데 이는 콜 스택 상에서 어떤 실행 컨텍스트가 활성된 상태일 뿐이다.

outerEnvironmentReference는 연결리스트(linked list) 형태를 띤다. 여러 스코프에서 동일한 식별자를 선언할 경우 **무조건 스코프 체인 상에서 가장 먼저 발견된 식별자에만 접근 가능**하게 된다.

#### 전역 변수와 지역 변수

전역 공간에서 선언한 변수는 전역변수이고, 함수 내부에서 선언한 변수는 무조건 지역변수이다. 코드의 안정성을 위해 가급적 전역변수 사용을 최소화하는 것이 좋다.

## this

실행 컨텍스트의 thisBinding에는 this로 지정된 객체가 저장된다. 실행 컨텍스트 활성화 당시에 this가 지정되지 않은 경우 this에는 전역 객체가 저장된다. 그 밖에는 함수를 호출하는 방법에 따라 this에 저장되는 대상이 다르다. 자세한건 다음장에서,,
