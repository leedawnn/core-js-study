# 01_데이터 타입

## 01_데이터 타입의 종류

- 기본형(primitive type)
    - 숫자, 문자열, 불리언, null, undefined
- 참조형(reference type)
    - 객체, 배열, 함수, 날짜, 정규표현식, ES6에서 추가된 Map, WeakMap, Set, WeakSet 등
- 기본형과 참조형의 구분기준
    - 기본형은 할당이나 연산시 복제, 참조형은 참조.

**(다만 기본형은 값이 담긴 주솟값을 바로 복제하는 반면, 참조형은 값이 담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값을 복제!!)**

## 02_데이터 타입에 관한 배경지식

### 1-2-1 메모리와 데이터

메모리는 0이나 1만 표현할 수 있는 비트 단위로 구성되어있다
각 비트는 고유한 식별자로 위치 확인 가능

**=> 비효율적**

그렇다면? 매우 많은 비트를 한 단위로 묶기 

**=> 검색시간과 표현 가능한 데이터 개수는 늘어나지만, 낭비되는 비트가 생김** 

자주 사용하지 않을 데이터를 표현하기 위해 빈 공간을 남기기보단, 표현 가능한 개수에 제약이 따르더라도 크게 문제가 되지 않을 적정한 공간을 묶는 게 낫다.

과거엔 메모리 공간이 작아 사용자가 형변환을 했어야 했으나, 메모리 용량이 커진 후 등장한 자바스크립트는 상대적으로 메모리 관리에 대한 압박에서 자유로워짐.

- 모든 데이터는 바이트 단위의 식별자, 더 정확하게는 **메모리 주솟값**을 통해 서로 구분하고 연결 가능!!

### 1-2-2 식별자와 변수

- 변수

    -변할 수 있는 수, 
    
    '수'가 붙었다고 반드시 숫자여야 할 필요는 x
    변할 수 있는 무언가 
    
    => 여기서 '무언가'는 **데이터**를 말한다.

## 변수 선언과 데이터 할당

### 1-3-1 변수 선언
```
var a;
```
"변할 수 있는 데이터를 만든다, 이 데이터의 식별자는 a로 한다" 는 의미가 된다.    
즉, 변수란 **변경 가능한 데이터가 담길 수 있는 공간 또는 그릇**이라고 볼 수 있다.

### 1-3-2 데이터 할당
```
01 var a; // 변수 a 선언
02 a = 'abc'; // 변수 a에 데이터 할당
03
04 var a = 'abc'; // 변수 선언과 할당을 한 문장으로 표현
```
데이터 할당에 대한 메모리 영역의 변화는 다음과 같다.
1. 변수 영역에서 빈 공간(@1003)을 확보
2. 확보한 공간의 식별자를 a로 지정
3. 데이터 영역의 빈공간(@5004)에 문자열 'abc' 를 저장 
4. 변수 영역에서 a라는 식별자를 검색(@1003)
5. 앞서 저장한 문자열의 주소(@5004)를 @1003의 공간에 대입

**굳이 변수 영역에 직접 대입하지 않고 한 단계를 더 거치는 이유는?**

메모리를 효율적으로 관리하기 위해, 문자열 데이터 변환을 처리하려면 변수와 데이터를 별도의 공간에 나누어 저장하는 것이 최적이다.
```
ex) 문자열 'abc'의 마지막에 'def'를 추가하려고 하면, 'abc'가 저장된 공간에 'abcdef' 를 할당하는 대신 'abcdef' 라는 문자열을 새로 만들어 별도의 공간에 저장하고, 그 주소를 변수 공간에 연결한다.
```
기존 문자열에 어떤 변환을 가하든 무조건 새로 만들어 별도 공간에 저장.

## 기본형 데이터와 참조형 데이터

### 1-4-1 불변값
변수와 상수를 구분하는 성질은? => '변경 가능성'

변수와 상수를 구분 짓는 변경 가능성의 대상은 **변수 영역** 메모리이다. 

한 번 데이터 할당이 이뤄진 변수 공간에 다른 데이터를 재할당할 수 있는지 여부가 관건이다.

```
01 var a = 'abc';
02 a = a + 'def';
03
04 var b = 5;
05 var c = 5;
06 b = 7;
```
01에서 변수 a에 할당 후, 02에서 def를 추가하면, 기존의 abc가 abcdef로 바뀌는 것이 아니라 새로운 문자열 abcdef를 만들어 그 주소를 변수 a에 저장

**abc와 abcdef는 완전히 별개의 데이터**

04에서 변수 b에 슷자 5할당한다. 컴퓨터는 데이터 영역에서 5를 찾고, 없으면 그제서야 데이터 공간을 하나 만들어 저장한다. 그 주소를 b에 저장한다. 5번째 줄에서는 다시 같은 수인 5를 할당한다. 컴퓨터는 데이터 영역에서 5를 찾고, 04에서 이미 만들어둔 값의 주소를 재활용한다. 

06에서는 변수 b를 7로 바꾸고자 한다. 기존에 저장된 5 자체를 7로 바꾸는 것이 아니라, 기존에 저장된 7이 있다면 재활용하고, 없으면 새로 만들어 b에 저장한다. 결국 5와 b 모두 다른 값으로 변경할 수 없다.

- 변경은 새로 만드는 동작을 통해서만 이루어짐, 이것이 불변값이 성질!  한 번 만들어진 값은 가비지 컬렉팅을 당하지 않는 한 영원불변하다.

```
- 가비지 컬렉팅(GC)이란?

가비지(Gabage) = 주소를 잃어버려서 사용할 수 없는 메모리가 '정리되지 않은 메모리'
즉, 가비지 컬렉팅은 메모리가 부족할 때, 이런 가비지들을 메모리에서 해제 시켜 다른 용도로 사용 할 수 있게 해주는 프로그램이다.
```

### 1-4-2 가변값
기본형 데이터는 모두 불변값이라고 했다. 그렇다면 참조형 데이터는 모두 가변값일까? 기본적인 성질은 가변값이지만, 설정에 따라 변경 불가능한 경우도 있고, 아예 불변값으로 활용하는 방안도 있다. 우선 참조형 데이터를 변수에 할당하는 과정을 확인하자.
```
var obj = {
    a: 1,
    b: 'bbb'
};
```

1. 변수 영역의 빈 공간(@5001) 확보 후, 그 주소 이름을 obj1으로 지정
2. 임의의 데이터 저장 공간에 데이터를 저장하려고 보니 여러 개의 프로퍼티로 이뤄진 데이터 그룹이다. 이 그룹 내부의 프로퍼티들을 저장하기 위해 별도의 변수 영역을 마련하고, 그 영역의 주소를 @5001에 저장
3. @7103 및 @7104에 각각 a와 b라는 프로퍼티 이름을 지정
4. 데이터 영역에 숫자 1을 검색, 검색 결과가 없으므로 다른 빈공간(@5003)에 저장 후, 이 **주소**를 @7103에 저장한다. 문자열 'bbb' 역시 임의로 @5004에 저장하고, 이 주소를 @7104에 저장한다.

```
property란?
- 키(key)와 값(value)이 연관된 객체(object)의 부분
- 객체 내에서 선언된 변수()를 의미

var obj = {
  x: 'local',
  y: 'global' 
}; 

obj.x; ---> local
-> x = key, 'local' = value => 둘을 합친 것 property
```
기본형 데이터와의 차이는 '객체의 변수(프로퍼티) 영역'이 별도로 존재한다는 점이다. 객체가 별도로 할애한 영역은 변수 영역일 뿐 '데이터 영역'은 기존의 메모리 공간을 그대로 활용. 데이터 영역에 저장된 값은 위에서 말했듯 모두 불변값이다. 그러나 변수에는 다른 값을 얼마든지 대입 가능하다. 

### 1-4-3 변수 복사 비교
기본형 데이터와 참조형 데이터의 차이를 확인해보자. 변수를 복사할 때의 변화를 살펴봅시다.

변수를 복사하는 과정은 데이터와 참조형 모두 같은 주소를 바라보게 되는 점에서 동일하다, 복사 과정은 동일하지만 데이터 할달 와정에서 이미 차이가 있기 때문에 변수 복사 이후의 동작에도 큰 차이가 발생한다.

```
01 var a = 10;
02 var b = a;
03 var obj1 = { c: 10, d: 'ddd' };
04 var obj2 = obj1;
05
06 b = 15;
07 obj2.c = 20;
```
06에서 데이터 영역에 15가 없으므로 새 공간 @5004에 저장하고, 그 주소를 든 채로 변수 영역에서 식별자가 b인 주소를 찾는다. 

07에서는 데이터 영역에 20이 없으므로 새 공간 @5005에 저장하고, 그 주소를 든채로 변수 영역에서 0bj2를 찾고(@1004), obj2의 값인 @5002가 가리키는 변수 영여겡서 다시 c를 찾아(@7103) 그곳에 @5005를 대입합니다.

기본형 데이터를 복사한 변수 b의 값을 바꿨더니 @1002의 값이 달라진 반면, 참조형 데이터를 복사한 변수 obj2의 프로퍼티의 값을 바꾸었더니 @1004의 값은 달라지지 않았습니다. 즉 변수 a와 b는 서로 다른 주소를 바라보게 됐으나, 변수 obj1과 obj2는 여전히 같은 객체를 바라보고 있는 상태이다.
이를 코드로 표현하면 다음과 같다.

객체의 프로퍼티 변경 시
```
a !== b
obj1 === obj2
```
이것이 기본형과 참조형 데이터의 가장 큰 차이점이다. 다만 기본형은 주솟값을 복사하는 과정이 한 번만 이뤄지고, 참조형은 한 단계를 더 거치게 된다는 차이가 있다. 

그렇다면 객체 자체를 변경했을 때는?
```
01 var a = 10;
02 var b = a;
03 var obj1 = { c: 10, d: 'ddd' };
04 var obj2 = obj1;
05
06 b = 15;
07 obj2.c = { c: 20, d: 'ddd'};
```
obj2에도 새로운 객체를 할당함으로써 값을 직접 변경, 매모리 데이터 영역의 새로운 공간에 새 객체가 저장되고 그 주소를 변수 영역의 obj2 위치에 저장할 것이다, 따라서 객체에 때한 변경임에도 값이 달라졌다.
**즉, 참조형 데이터가 가변값이라고 설명할 때의 가변은 참조형 데이터 자체를 변경할 경우가 아니라 그 내부의 프로퍼티를 변경할 때만 성립한다.**

## 05_불변 객체

### 1-5-1 불변 객체를 만드는 간단한 방법
데이터 자체를 변경하고자 하면(새로운 데이터를 할당하고자 하면) 기본형 데이터와 마찬가지로 **기존 데이터는 변하지 않습니다.** 그렇다면 내부 프로퍼티를 변경할 필요가 있을 때마다 매변 새로운 객체를 만들어 재할당하기로 규칙을 정하거나 자동으로 새로운 객체를 만드는 도구를 활용한다면 객체 역시 불변성을 확보할 수 있을 것입니다. 

그럼 어떤 상황에서 불변 객체가 필요할까요? **값으로 전달받은 객체에 변경을 가하더라도 원본 객체는 변하지 않아야 하는 경우가 종종 발생합니다.** 바로 이럴 때 불변 객체가 필요합니다.

즉, 서로 다른 객체를 바라보게 만들어야 합니다. 

### 1-5-2 얕은 복사와 깊은 복사
얕은 복사는 바로 아래 단계의 값만 복사하는 방법이고, 깊은 복사는 내부의 모든 값들을 하나하나 찾아서 복사하는 방법입니다. 즉 얕은 복사란 중첩된 객체에서 참조형 데이터가 저장된 프로퍼티를 복사할 때 그 주솟값만 복사한다는 의미이다. 그러면 해당 프로퍼티에 대해 원본과 사본이 모두 동일한 참조형 데이터의 주소를 가리키게 된다. 

**따라서 얕은 복사의 경우, 사본을 바꾸면 원본도 바뀌고, 원본을 바꾸면 사본도 바뀐다.**

user 객체에 직접 속한 프로퍼티에 대해서는 복사해서 완전히 새로운 데이터가 만들어진 반면, 한 단계 더 들어간 urls의 내부 프로퍼티들은 **기존 데이터를 그대로 참조**한다. 이런 현상이 발생하지 않게 하려면 user.urls 프로퍼티에 대해서도 불변 객체로 만들 필요가 있다.

그러니 어떤 객체를 복사할 때 객체 내부의 모든 값을 복사해 완전히 새로운 데이터를 만들고자 할 때, 객체의 프로퍼티 중에서 그 값이 **기본형 데이터인 경우에는 그래로 복사**하면 되지만 **참조형 데이터는 다시 그 내부의 프로퍼티들을 복사**해야 한다. 

## 06_undefined와 null
자바스크립트에는 '없음'을 나타내는 두 가지 값 => undefined와 null
```
undefined
사용자가 명시적이로 지정도 가능함, 자바스크립트 엔진이 자동으로 부여하는 경우는? = 응당 어떤 값을 지정할 것이라고 예상되는 상황임에도 실제로는 그렇게 하지 않았을 때 반환됨

    1. 값을 대입하지 않은 변수가 식별자에 접근할 때
    2. 객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할 때
    3. return 문이 없거나 호출되지 않는 함수의 실행 결과
``` 


undefined와 null을 비교할 때 동등연산자(==)로 비교할 경우 서로 같다고 판단한다. 따라서 일치 연산자(===)를 써야만 정확한 판별이 가능합니다.


    

