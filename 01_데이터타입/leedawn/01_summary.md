# 데이터 타입

- 1장 목표 : 자바스크립트가 데이터를 처리하는 과정을 살펴봄으로써 기본형 타입과 참조형 타입이 서로 다르게 동작하는 이유를 이해하자. 

## 데이터 타입의 종류

- 기본형(원시형, primitive type)
  - 숫자, 문자열, 불리언, null, undefined 등과 ES6에서 symbol이 추가됨.
- 참조형(reference type)
  - 객체, 배열, 함수, 날짜, 정규표현식 등과 ES6에서 추가된 Map, WeakMap, Set, WeakSet 등이 객체의 하위 분류에 속한다.

**그렇다면 어떤 기준으로 원시형과 참조형을 구분하는걸까?**

원시형은 값이 담긴 주소값을 바로 복제한다.
반면, 참조형은 값이 담긴 주소값들로 이루어진 묶음을 가리키는 주소값을 복제한다.

## 데이터 타입에 관한 배경지식

### 1-2-1 | 메모리와 데이터

C/C++, 자바 등의 정적 타입 언어는 메모리의 낭비를 최소화하기 위해 데이터 타입별로 할당할 메모리 영역을 2바이트, 4바이트 등으로 나누어 정해놓았다. 메모리 용량이 부족했던 시절에는 이런 식으로 메모리 효율을 챙겼다. 

한편 메모리 용량이 과거보다 월등히 커진 상황에서 등장한 자바스크립트는 상대적으로 자유로웠음. 따라서, 숫자의 경우 정수형인지 부동소수형인지를 구분하지 않고 8바이트를 확보한다.

각각의 비트는 고유한 식별자를 지니며, 바이트 역시 시작하는 비트의 식별자로 위치를 파악할 수 있다. 모든 데이터는 **메모리 주소값**을 통해 서로 구분하고 연결할 수 있다. 


### 1-2-2 | 식별자와 변수

- 변수 : 변할 수 있는 데이터값
- 식별자 : 어떤 데이터를 식별하는 데 사용하는 이름, 즉 변수명

## 변수 선언과 데이터 할당

### 1-3-1 | 변수 선언

```javascript
var a;
```

**변수 선언 과정**

1. 메모리에서 비어있는 공간 하나를 확보한다. 
2. 임의의 주소 1003번, 이 공간의 이름(식별자)을 a라고 지정한다.
  
### 1-3-2 | 데이터 할당

```javascript
var a; // 변수 a 선언
a = 'abc'; // 변수 a에 데이터 할당

var a = 'abc'; // 변수 선언과 할당을 한 문장으로 표현
```

a라는 이름을 가진 주소를 검색해서 그곳에 문자열 'abc'를 할당하면 될 것 같지만,, 실제로는 해당 위치에 문자열 'abc'를 직접 저장하지 않는다!

데이터를 저장하기 위한 별도의 메모리 공간을 다시 확보해서 문자열 'abc'를 저장하고, 그 주소를 변수 영역에 저장하는 식으로 이뤄진다. 

또한, 데이터의 성질에 따라 **변수 영역**과 **데이터 영역**으로 구분된다.


**데이터 할당의 전체 흐름**

1. 변수 영역에서 빈 공간(@1003)을 확보한다.
2. 확보한 공간의 식별자를 a로 지정한다.
3. 데이터 영역의 빈 공간(@5004)에 문자열 'abc'를 저장한다.
4. 변수 영역에서 a라는 식별자를 검색한다(@1003)
5. 앞서 저장한 문자열의 주소(@5004)를 @1003의 공간에 대입한다.

**왜 변수 영역에 값을 직접 대입하지 않고 굳이 번거롭게 한 단계를 더 거치는 걸까?**

이는 데이터 변환을 자유롭게 할 수 있게 함과 동시에 메모리를 더욱 효율적으로 관리하기 위한 고민의 결과이다. 

자바스크립트는 숫자형 데이터에 대해서 8바이트의 공간을 확보하지만, 문자열은 특별히 정해진 규격이 없다. 데이터에 따라 가변적이다.

미리 확보한 공간 내에서만 데이터 변환을 할 수 있다면 변환한 데이터를 다시 저장하기 위해 '**확보된 공간을 변환된 데이터 크기에 맞게 늘리는 작업**'이 선행되어야할 것이다. 

결국, **효율적으로 문자열 데이터의 변환을 처리하려면 변수와 데이터를 별도의 공간에 나누어 저장하는 것이 최적이다.**

#### 이미 선언된 변수에 문자열을 추가한다면?

문자열 'abc'의 마지막에 'def'를 추가한다고 가정해보자.

앞서 'abc'가 저장된 공간에 'abcdef'를 할당하는 대신 'abcdef'라는 **문자열을 새로 만들어 별도의 공간에 저장하고, 그 주소를 변수 공간에 연결한다.**

즉, 기존 문자열을 변환한다고 하면 새로 만들어 별도의 공간에 저장한다. 


다른 예로, 500개의 변수를 생성해서 모든 변수에 숫자 5를 할당하는 상황을 가정해보자.

각 변수 공간마다 매번 숫자 5를 할당하려고 하면 4000(500 * 8)바이트를 써야할 것이다. 그 대신 5를 별도의 공간에 한 번만 저장하고 해당 주소만 입력한다면 필요한 주소 공간의 크기가 크게 줄어들 것이다. 

이처럼 변수 영역과 데이터 영역을 분리하면 중복된 데이터에 대한 처리 효율이 높아진다. 


## 기본형 데이터와 참조형 데이터

### 1-4-1 | 불변값

**상수 !== 불변값**

변수와 상수를 구분 짓는 변경 가능성의 대상은 **변수 영역** 메모리이다. 한 번 데이터 할당이 이뤄진 변수 공간에 다른 데이터를 재할당할 수 있는지 여부가 관건이다. 

반면 불변성 여부를 구분할 때의 변경 가능성의 대상은 **데이터 영역** 메모리이다. 원시형 데이터인 숫자, 문자열, boolean, null, undefined, Symbol은 모두 불변값이다. 

```javascript
var a = 'abc';
a = a + 'def';

var b = 5; 
var c = 5;
b = 7;
```

1~2번째 줄에서 변수 a에 'abc'를 할당했다가 뒤에 'def'를 추가하면, 기존의 'abc'가 'abcdef'로 바뀌는 것이 아니라 새로운 문자열 'abcdef'를 만들어 그 주소를 변수 a에 저장한다. 즉, 'abc'와 'abcdef'는 완전히 별개의 데이터이다. 

4번째 줄에서는 일단 데이터 영역에서 5를 찾고, 없으면 그제서야 데이터 공간을 하나 만들어 저장한다. 

6번째 줄에서는 변수 b의 값을 7로 바꾸고자 한다. 기존에 저장된 5 자체를 7로 바꾸는 것이 아니라 기존에 저장했던 7이 있으면 재활용하고, 없으면 새로 만들어서 b에 저장한다. 결국 5와 7 모두 다른 값으로 변경할 수 없다!!!

**문자열이나 숫자 모두 한 번 만든 값은 바꿀 수 없다! 변경은 새로 만드는 동작을 통해서만 이뤄진다. 이것이 바로 불변값의 성질이다. 한 번 만들어진 값은 가비지 컬렉팅을 당하지 않는 한 영원히 변하지 않는다.**

### 1-4-2 | 가변값

**참조형 데이터를 변수에 할당하는 과정**

1. 컴퓨터는 우선 변수 영역의 빈 공간(@1002)를 확보하고, 그 주소의 이름을 obj1로 지정한다.
2. 임의의 데이터 저장 공간(@5001)에 데이터를 저장하려고 보니 객체이므로, 별도의 변수 영역을 마련하고, 그 영역의 주소(@7103 ~ ?)를 @5001에 저장한다.
3. @7103 및 @7104에 각각 a와 b라는 프로퍼티 이름을 지정한다. 
4. 데이터 영역에서 숫자 1을 검색한다. 검색 결과가 없으므로 임의로 @5003에 저장하고, 이 주소를 @7103에 저장한다. 문자열 'bbb' 역시 임의로 @5004에 저장하고, 이 주소를 @7104에 저장한다.

원시형 데이터와의 차이는 '객체의 변수(프로퍼티) 영역'이 별도로 존재한다는 점이다. 데이터 영역에 저장된 값은 모두 불변값이다. 그러나 변수에는 다른 값을 얼마든지 대입할 수 있다. 바로 이 부분 때문에 흔히 참조형 데이터는 불변(immutable)하지 않다(가변값이다)라고 하는 것이다.

```javascript
var obj1 = {
  a: 1,
  b: 'bbb'
};

obj1.a = 2;
```

**참조형 데이터의 프로퍼티 재할당**

obj1의 a 프로퍼티에 숫자 2를 할당하려고 할 때, 먼저 데이터 영역에서 숫자 2를 검색한다. 검색 결과가 없으므로 빈 공간인 @5005에 저장하고, 이 주소를 @7103에 저장한다. 

변수 obj1이 바라보고 있는 주소는 @5001로 변하지 않았다. 즉, **'새로운 객체'가 만들어진 것이 아니라 기존의 객체 내부의 값만 바뀐 것!**

### 가비지 컬렉터의 작동 원리

어떤 데이터에 대해 자신의 주소를 참조하는 변수의 개수를 **참조 카운트**라고 한다. 참조 카운트가 0인 메모리 주소는 가비지 컬렉터의 수거 대상이 된다. 가비지 컬렉터는 런타임 환경에 따라 특정 시점이나 메모리 사용량이 포화 상태에 임박할 때마다 자동으로 수거 대상들을 수거한다. 수거된 메모리는 다시 새로운 값을 할당할 수 있는 빈 공간이 된다. 

### 1-4-3 | 변수 복사 비교

변수를 복사하는 과정은 원시형 데이터와 참조형 데이터 모두 같은 주소를 바라보게 되는 점에서 동일하다. 복사 과정은 동일하지만 데이터 할당 과정에서 이미 차이가 있기 때문에 변수 복사 이후의 동작에서는 큰 차이가 발생한다.

**변수 복사 이후 값 변경 결과 비교 - 객체의 프로퍼티 변경 시**

```javascript
var a = 10;
var b = a;
var obj1 = { c: 10, d: 'ddd' };
var obj2 = obj2;

b = 15;
obj2.c = 20;
```

원시형 데이터를 복사한 변수 b의 값을 바꾸게 되면 그 값을 참조하는 주소값이 달라진다. 반면 참조형 데이터를 복사한 변수 obj2의 프로퍼티의 값을 바꿀 때의 참조하는 주소값은 달라지지 않는다. 즉, 변수 a와 b는 서로 다른 주소를 바라보게 됐으나, 변수 obj1과 obj2는 여전히 같은 객체를 바라보고 있는 상태이다. 이를 코드로 표현하면 다음과 같다.

```javascript
a !== b
obj1 === obj2
```

이 결과가 바로 원시형과 참조형 데이터의 가장 큰 차이점이다.

**어떤 데이터 타입이든 변수에 할당하기 위해서는 주소값을 복사해야 하기 때문에, 엄밀히 따지면 자바스크립트의 모든 데이터 타입은 참조형 데이터일 수 밖에 없다. 원시형은 주소값을 복사하는 과정이 한 번만 이뤄지고, 참조형은 한 단계를 더 거치게 된다는 차이가 있는 것이다.**


**변수 복사 이후 값 변경 결과 비교 - 객체 자체를 변경했을 때**

```javascript
var a = 10;
var b = a;
var obj1 = { c: 10, d: 'ddd' };
var obj2 = obj2;

b = 15;
obj2 = { c: 20, d: 'ddd' };
```

이번에는 b의 경우와 같이 obj2에도 새로운 객체를 할당함으로써 값을 직접 변경했다. 그러면 메모리의 데이터 영역의 새로운 공간에 새 객체가 저장되고 그 주소를 변수 영역의 obj2 위치에 저장한다. 이렇듯 객체에 대한 변경임에도 값이 달라졌다!

**즉, 참조형 데이터가 '가변값'이라고 설명할 때의 '가변'은 참조형 데이터 자체를 변경할 경우가 아니라 그 내부의 프로퍼티를 변경할 때만 성립한다.**


## 불변 객체

### 1-5-1 | 불변 객체를 만드는 간단한 방법

데이터 자체를 변경하고자 하면(새로운 데이터를 할당하고자 하면) 기본형 데이터와 마찬가지로 **기존 데이터는 변하지 않는다.**

그렇다면 내부 프로피터를 변경할 필요가 있을 때마다 매번 새로운 객체를 만들어 재할당하기로 규칙을 정하거나 자동으로 새로운 객체를 만드는 도구(immutable.js, immer.js 등이나 ES6의 스프레드 연산자, Object.assign 등)를 활용한다면 객체 역시 불변성을 확보할 수 있을 것이다.

**그럼 어떤 상황에서 불변 객체가 필요할까?**

값으로 전달받은 객체에 변경을 가하더라도 원본 객체는 변하지 않아야하는 경우가 종종 발생한다. 바로 이럴 때 불변 객체가 필요하다. 예를 들어, 정보가 바뀐 시점에 알림을 보내야 한다거나, 바뀌기 전의 정보와 바뀐 후의 정보의 차이를 가시적으로 보여줘야 하는 등의 기능을 구현하는 등의 경우가 있겠다.


### 1-5-2 | 얕은 복사와 깊은 복사

얕은 복사란 중첩된 객체에서 참조형 데이터가 저장된 프로퍼티를 복사할 때 그 주소값만 복사한다는 의미이다. 그러면 해당 프로퍼티에 대해 원본과 사본이 모두 동일한 참조형 데이터의 주소를 가리키게 된다. 사본을 바꾸면 원본도 바뀌고, 원본을 바꾸면 사본도 바뀐다.

이런 현상이 발생하지 않게 하려면 중첩된 객체에 대한 깊은 복사가 이루어져야한다. 어떤 객체를 복사할 때 객체 내부의 모든 값을 복사해서 완전히 새로운 데이터를 만들고자 할 때, 객체의 프로퍼티 중에서 그 값이 원시형 데이터일 경우에는 그대로 복사하면 되지만 참조형 데이터는 다시 그 내부의 프로퍼티들을 복사해야한다. 이것을 바로 깊은 복사를 의미한다.

getter/setter까지 복사되는 진정한(?) 깊은 복사를 하기 위한 방법은 ES6의 Object.getOwnPropertDescriptor 또는 ES2017의 Object.getOwnPropertDescriptors 외에는 마땅한 방법이 없다.

간단하게 깊은 복사를 처리할 수 있는 방법으로는 객체를 JSON 문법으로 표현된 문자열로 전환했다가 다시 JSON 객체로 바꾸는 것이다. 이 방법은 단순함에도 불구하고 잘 동작한다. 다만 메서드나 숨겨진 프로퍼티인 __proto__나 getter/setter 등과 같이 JSON으로 변경할 수 없는 프로퍼티들은 모두 무시한다.

## undefined와 null

자바스크립트 엔진은 사용자가 응당 어떤 값을 지정할 것이라고 예상되는 상황임에도 실제로는 그렇게 하지 않았을 때 `undefined`를 반환한다. 아래와 같은 3가지 경우가 이에 해당한다.

1. 값을 대입하지 않은 변수, 즉 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할 때
2. 객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할 때  
3. return문이 없거나 호출되지 않는 함수의 실행 결과

`null`은 한 가지 주의할 점이 있다. 바로 `typeof null`이 `object`라는 점이다. 이는 자바스크립트 자체 버그이다. 따라서 어떤 변수의 값이 null인지 여부를 판별하기 위해서는 일치 연산자(===)를 사용하자.


