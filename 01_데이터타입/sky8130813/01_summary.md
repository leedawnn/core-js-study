# 데이터 타입

- 자바스크립트가 테이터를 처리하는 과정을 살펴 봄.
- 기본형(원시형) 타입과 참조형 타입이 서로 다르게 동작하는 이유를 이해하고 적절한 활용을 목표.

## 01 | 데이터 타입의 종류

- 기본형 (원시형, primitive type)
  - 숫자, 문자열, 불리언, null, undefined 등 (ES6에서 symbol 추가)
- 참조형 (reference type)
  - 객체, 배열, 함수, 날짜, 정규표현식 등과 ES6에서 추가된 Map, WeakMap, Set, WeakSet 등이 객체의 하위 분류에 속함.

**기본형 참조형 구분**

- 기본형(원시형)
  - 할당이나 연산시 복제.
  - 값이 담긴 주솟값 바로 복제.
- 참조형
  - 참조.
  - 값이 담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값을 복제.

## 02 | 데이터 타입에 관한 배경지식

### 2-1 메모리와 데이터

컴퓨터는 모든 데이터를 0 또는 1로 바꿔 기억하고,
0 또는 1만 표현할 수 있는 메모리 조각을 **비트**라고 함.

각 비트는 고유한 식별자를 통해 위치를 확인할 수 있는데 비트 단위로 위치를 확인하는 건 **비효율적**.

여러 개로 묶어 하나의 단위로 묶으면서, 표현 할수 있는 값도 증가 + 검색 시간 단축 -> 낭비되는 비트 발생.

표현 가능한 개수에 제약이 따르더라도 크게 문제가 되지 않을 적정 공간을 묶음 -> 바이트(byte) 단위 탄생.

C/C++, 자바 등 정적 타입 언어는 타입 별 할당 메모리 영역을 2바이트, 4바이트 등으로 나누어 정함. (사용자가 직접 4바이트 크기의 정수형 타입 등으로 형변환 해햐 함)

자바스크립트는 상대적으로 메모리 관리가 자유로움.

모든 데이터는 바이트 단위의 식별자, **메모리 주솟값**을 통해 서로 구분하고 연결할 수 있음.

### 2-2 식별자와 변수

- 변수
  - 변할 수 있는 **데이터 값**
- 식별자
  - 어떤 데이터를 식별하는 데 사용하는 이름, 즉 **변수명**

## 03 | 변수 선언과 데이터 할당

### 3-1 변수 선언과 데이터 할당

```js
var a;
```

> "변할 수 있는 데이터를 만든다. 이 데이터의 식별자는 a로 한다"
>
> 변수: 변경 가능한 데이터가 담길 수 있는 공간 또는 그릇

**변수 선언에 대한 메모리 영역 변화 (변수 선언 과정)**

변수 선언으로 명령을 받은 컴퓨터는,

1. 메모리에 비어있는 공간 하나를 확보
2. 임의로 1003번 지정, 확보한 공간의 이름(식별자)을 a라고 지정.

   `이후에 사용자가 a에 접근하고자 하면 메모리에서 a라는 이름을 가진 주소를 검색, 해당 공간에 담긴 데이터를 반환.`

### 3-2 데이터 할당

```js
var a; // 변수 a 선언
a = "abc"; // 변수 a에 데이터 할당

var a = "abc"; // 변수 선언과 할당을 한 문장을 표현
```

> a라는 이름을 가진 주소를 검색해서 그곳에 문자열 'abc'를 할당?
>
> 해당 위치에 문자열 'abc'를 직접 저장하지 않음.
>
> 1. 데이터 저장을 위한 별도 메모리 공간 다시 확보
> 2. 문자열 'abc' 저장
> 3. 그 주소를 변수 영역에 저장
>
> **데이터 성질에 따라 '변수 영역', '데이터 영역'으로 구분.**

**데이터 할당의 전체 흐름**

1. 변수 영역에서 빈 공간(@1003)을 확보
2. 확보한 공간의 식별자를 a로 지정
3. 데이터 영역의 빈 공간(@5004)에 문자열 'abc'를 저장
4. 변수 영역에서 a라는 식별자를 검색(@1003)
5. 앞서 저장한 문자열의 주소(@5004)를 @1003의 공간에 대입

**왜 변수 영역에 값을 직접 대입하지 않고 궅이 번거롭게 한 단계를 더 거칠까?**

데이터 변환을 자유롭게 할 수 있게 함 + 메모리를 더욱 효율적으로 관리하기 위한 고민의 결과.

숫자형 데이터는 64비트(8바이트)의 공간을 확보하지만, 문자열을 정해진 규격이 없고 가변적.

미리 확보한 공간 내에서만 데이터 변환을 할 수 있다면 변환한 데이터를 다시 저장하기 위해 '**확보된 공간을 변환된 데이터 크기에 맞게 늘리는 작업**' 선행 필요.

효율적으로 문자열 데이터의 변환을 처리하려면 **변수와 데이터를 별도의 공간에 나누어 저장이 최적**.

> **이미 선언된 변수에 추가 시...**
>
> 문자열 'abc'의 마지막에 'def'를 추가 하려면, 'abc'가 저장된 공간에 'abcdef' 를 할당하는 대신 'abcdef' 라는 문자열을 **새로 만들어 별도의 공간에 저장**하고, **그 주소를 변수 공간에 연결**.
>
> **기존 문자열에 어떤 변환을 가하든 상관 없이 무조건 새로 만들어 별도의 공간에 저장**

> 다른 예, 500개의 변수를 생성해서 모든 변수에 숫자 5를 할당하는 상황.
>
> 각 변수 공간마다 매번 숫자 5를 할당하려고 하면 4000(500 \* 8)바이트를 써야함. 그 대신 5를 별도의 공간에 한 번만 저장하고 해당 주소만 입력한다면 필요한 주소 공간의 크기가 크게 줄어듦.
>
> 이처럼 변수 영역과 데이터 영역을 분리하면 중복된 데이터에 대한 처리 효율이 높아짐.

## 04 | 기본형 데이터와 참조형 데이터

### 4-1 불변값

변수와 상수를 구분한 성질, **변경 가능성**.

변경 가능성 대상은 **변수 영역** 메모리. 한 번 데이터 할당이 이뤄진 변수 공간에 다른 데이터를 재할당할 수 있는지 여부가 관건.

불변성 여부를 구분할 때의 변경 가능성의 대상, **데이터 영역** 메모리.

기본형(원시형) 데이터: 숫자, 문자열, boolean, null, undefined, Symbol은 모두 **불변값**.

```js
var a = "abc";
a = a + "def";

var b = 5;
var c = 5;
b = 7;
```

> 1~2번째 줄에서 변수 a에 'abc'를 할당했다가 뒤에 'def'를 추가하면, 기존의 'abc'가 'abcdef'로 바뀌는 것이 아니라 새로운 문자열 'abcdef'를 만들어 그 주소를 변수 a에 저장.
>
> **'abc'와 'abcdef'는 완전히 별개의 데이터**.
>
> 4번째 줄에서는 변수 b에 숫자 5 할당. 데이터 영역에서 5 찾고, 없으면 데이터 공간을 하나 만들어 저장, 그 주소를 b에 저장.
>
> 5번째 줄에서는 다시 같은 수인 5 할당하려고 함. 데이터 영역에서 5를 찾고, 4번째 줄에서 이미 만들어 놓은 값이 있으니, 그 주소를 재활용.
>
> 6번째 줄에서는 변수 b의 값을 7로 바꾸려면, 기존에 저장된 5 자체를 7로 바꾸는 것이 아니라 기존에 저장했던 7이 있으면 재활용, 없으면 새로 만들어서 b에 저장. 결국 5와 7 모두 다른 값으로 변경할 수 없음.
>
> **문자열이나 숫자 모두 한 번 만든 값은 바꿀 수 없음. 변경은 새로 만드는 동작을 통해서만 가능. 이것이 바로 불변값의 성질. 한 번 만들어진 값은 가비지 컬렉팅을 당하지 않는 한 영원히 변하지 않음**.

### 4-2 가변값

기본형 데이터는 모두 불변값. 참조형 데이터는 모두 가변값?

기본적인 성질은 가변값이지만 설정에 따라 변경 불가능한 경우, 불변값으로 활용하는 방안 등 존재.

**참조형 데이터를 변수에 할당하는 과정**

```js
var obj = {
  a: 1,
  b: "bbb",
};
```

> 1. 변수 영역의 빈 공간(@5001) 확보 후, 그 주소 이름을 obj1으로 지정
> 2. 임의의 데이터 저장 공간에 데이터를 저장하려고 보니 여러 개의 프로퍼티로 이뤄진 데이터 그룹. 이 그룹 내부의 프로퍼티들을 저장하기 위해 별도의 변수 영역을 마련하고, 그 영역의 주소를 @5001에 저장
> 3. @7103 및 @7104에 각각 a와 b라는 프로퍼티 이름을 지정
> 4. 데이터 영역에 숫자 1을 검색, 검색 결과가 없으므로 다른 빈공간(@5003)에 저장 후, 이 주소를 @7103에 저장. 문자열 'bbb' 역시 임의로 @5004에 저장하고, 이 주소를 @7104에 저장.
>
> 기본형 데이터와의 차이는 '객체의 변수(프로퍼티) 영역'이 별도로 존재.
>
> 객체가 별도로 할애한 영역은 변수 영역일 뿐 '데이터 영역'은 기존 메모리 공간을 그대로 활용.
>
> 데이터 영역에 저장된 값은 모두 불변값. 그러나 변수에 다른 값을 얼마든지 대입 가능.
>
> **이부분 때문에 참조형 데이터는 불변하지 않다(가변값)** 라고 함.

**참조형 데이터의 프로퍼티 재할당**

```js
var obj1 = {
  a: 1,
  b: "bbb",
};
obj1.a = 2;
```

> 1. obj1의 a 프로퍼티에 숫자 2를 할당, 데이터 영역에 숫자 2 검색.
> 2. 검색 결과가 없음, 빈 공간 @5005에 저장, 이 주소를 @7103에 저장.
>
> 4번째 줄의 명령 전과 후에 변수 obj1이 바라보고 있는 주소는 @5001로 변하지 않음.
> '**새로운 객체**'가 만들어진 것이 아니라 기존의 객체 내부의 값만 바뀐 것.

**_가비지 컬렉터(GC)_**

어떤 데이터에 대해 자신의 주소를 참조하는 변수의 개수를 참조 카운트라고 함.
참조 카운트가 0인 메모리 주소는 가비지 컬렉터의 수거 대상이 됨. (주소를 참조하는 변수의 개수가 없는 경우)

런타임 환경에 따라 특정 시점이나 메모리 상용량이 포화 상태에 임박할 때마다 자동으로 수거 대상들을 수거. 수거된 메모리는 다시 새로운 값을 할당할 수 있는 빈공간이 됨.
(프로그램에서 할당했지만 더 이상 참조되지 않는 메모리를 회수하려고 시도)

### 4-3 변수 복사 비교

변수를 복사하는 과정은 기본형 데이터와 참조형 데이터 모두 같은 주소를 바라보게 되는 점에서 동일.
복사 과정은 동일하지만 데이터 할당 과정에서 차이가 있기 때문에 변수 복사 이후 동작에도 큰 차이가 발생.

**변수 복사 이후 값 변경 겨로가 비교 - 객체의 프로퍼티 변경 시**

```js
var a = 10;
var b = a;
var obj1 = { c: 10, d: "ddd" };
var obj2 = obj2;

b = 15;
obj2.c = 20;
```

> 6번째 줄에서 데이터 영역에 아직 15가 없으므로 새로운 공간 @5004에 저장, 그 주소를 든 채로 변수 영역에서 식별자가 b인 주소를 찾음.
>
> 7번째 줄에서 데이터 영역에 아직 20이 없으므로 새로운 공간 @5005에 저장, 그 주소를 든 채로 변수 영역에서 obj2를 찾고(@1004), obj2의 값인 @5002가 가리키는 변수 영역에서 다시 c를 찾아(@7103) 그곳에 @5005를 대입.
>
> 기본형 데이터를 복사한 변수 b의 값을 바꿨더니 @1002의 값이 달라진 반면, 참조형 데이터를 복사한 변수 obj2의 프로퍼티의 값을 바꾸었더니 @1004의 값은 달라지지 않음.
>
> 즉, 변수 a와 b는 서로 다른 주소를 바라보게 됐으나, 변수 obj1, obj2는 여전히 같은 객체를 바라보고 있는 상태.

이를 코드로 표현한다면,

```js
a !== b;
obj1 === obj2;
```

이 결과가 기본형과 참조형 데이터의 가장 큰 차이점.

'기본형은 값을 복사하고 참조형은 주솟값을 복사한다'

-> '기본형은 주솟값을 복사하는 과정이 한 번만 이뤄지고, 참조형은 한 단계를 더 거치게 된다'

-> '기본형도 결국 주솟값을 참조한다'

**변수 복사 이후 값 변경 결과 비교 - 객체 자체를 변경했을 때**

```js
var a = 10;
var b = a;
var obj1 = { c: 10, d: "ddd" };
var obj2 = obj2;

b = 15;
obj2 = { c: 20, d: "ddd" };
```

> obj2에도 새로운 객체를 할당함으로써 값을 직접 변경.
>
> 메모리 데이터의 영역의 새로운 공간에 새 객체가 저장되고 그 주소를 변수 영역의 obj2 위치에 저장.
>
> 객체에 대한 변경임에도 값이 달라짐.
>
> **즉, 참조형 데이터가 '가변값'이라고 설명할 때 '가변'은 참조형 데이터 자체를 변경할 경우가 아니라 그 내부의 프로퍼티를 변경할 때만 성림!**

## 05 | 불변 객체

### 5-1 불변 객체를 만드는 간단한 방법

데이터 자체를 변경하고자 하면(새로운 데이터를 할당하고자 하면) 기본형 데이터와 마찬가지로 **기존 데이더는 변하지 않음**. 그렇다면 내부 프로퍼티를 변경할 필요가 있을 때마다 매번 새로운 객체를 만들어 재할당하기로 규칙을 정하거나 자동으로 새로운 객체를 만드는 도구(immutable.js, immer.js immutability-helper 등의 라이브러리, ES6의 스프레드 연산자, Object.assign 메서드 등)를 활용한다면 객체 역시 불변성을 확보할 수 있을 것.

**어떤 상황에서 불변 객체가 필요할까?**

값으로 전달받은 객체에 변경을 가하더라도 원본 객체는 변하지 않아야 하는 경우, 불변 객체가 필요.

예를 들어, 정보가 바뀐 시점에서 알림을 보내야 하거나, 바뀌기 전의 정보와 바뀐 후의 정보의 차이를 가시적으로 보여줘야 하는 등의 기능을 구현할 때 필요.

### 5-2 얕은 복사와 깊은 복사

- 얕은 복사
  - 바로 아래 단계의 값만 복사하는 방법.
  - 중첩된 객체에서 참조형 데이터가 저장된 프로퍼티를 복사할 때 그 주솟값만 복사한다는 의미.
  - 해당 프로퍼티에 대해 원본과 사본 모두 동일한 참조형 데이터 주소를 가리키게 되면서, **사본을 바꾸면 원본도 바뀌고 원본을 바꾸면 사본도 바뀜**.
- 깊은 복사
  - 내부의 모든 값들을 하나하나 찾아서 전부 복사하는 방법.

어떤 객체를 복사할 때 객체 내부의 모든 값을 복사해서 완전히 새로운 데이터를 만들고자 할 때, 객체의 프로퍼티 중에서 그 값이 **기본형 데이터일 경우, 그대로 복사** 하면 되지만 **참조형 데이터는 다시 그 내부의 프로퍼티들을 복사**해야함. 이 것이 **깊은 복사**.

ES5의 `getter/setter`까지 복사하는 방법은 ES6의 `Object.getOwnPropertyDescriptor` 또는 ES2017의 `Object.getOwnPropertyDescriptors` 외에는 마땅한 방법이 없음.

간단하게 깊은 복사를 처리할 수 있는 방법으로 객체를 JSON 문법으로 표현된 문자열로 전환했다가 다시 JSON 객체로 바꾸는 것. 이 방법은 단순함에도 불구하고 잘 동작함. 다만 메서드(함수)나 숨겨진 프로퍼티인 `__proto__`나 `getter/setter`등과 같이 JSON으로 변경할 수 없는 프로퍼티들은 모두 무시.
httpRequest로 받은 데이터를 저장한 객체를 복사할 때 등 순수한 정보만 다룰 때 활용하기 좋은 방법.

## 06 | undefined와 null

자바스크립트에서 '없음'을 나타내는 값 두 가지.

- undefined
  - 사용자가 명시적을 지정 또는 값이 존재하지 않을 때 자바스크립트 엔진이 자동으로 부여
  - 사용자가 어떤 값을 지정할 것이라고 예상되는 사오항임에도 실제로는 그렇게 하지 않았을 때 반환
    1. 값을 대입하지 않은 변수. 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근 할 때.
    2. 객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할 때
    3. return 문이 없거나 호출되지 않는 함수의 실행 결과
  - 사용자가 명시적으로 부여한 undefined
    - undefined그 자체로 값. '비어있음'을 의미하지만 하나의 값으로 동작하기 때문에 프로퍼티나 배열의 요소는 고유의 키값(프로퍼티 이름)이 실존하게 되고 순회의 대상이 될 수 있음.
    - **실존하는 데이터**
  - 비어있는 요소에 접근하려 핼 때 반환되는 undefined (사용자가 아무것도 하지 않은 채로 접근 했을 때 자바스크립트 엔진이 하는 수 없이 반환 해주는 undefined)
    - 해당 프로퍼티 내지 배열의 키값(인덱스) 자체가 존재하지 않음을 의미
    - **값이 없음을 나타냄**
- null
  - '비어있음'을 명시적으로 나타내고 싶을 때는 null을 쓰면 됨.
  - 이런 규칙을 따르면 '값을 대입하지 않은 변수에 접근하고자 할 때 자바스크립트 엔진이 반환 해주는 값, undefined'로 존재할 수 있음.
  - typeof null이 object. 자바스트립트 자체 버그.
  - **undefined == null / undefined !== null**
