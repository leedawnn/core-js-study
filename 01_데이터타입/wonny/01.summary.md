# 1. 데이터 타입
### 목표
**기본형 타입, 참조형 타입이 서로 다르게 동작하는 이유가 무엇인지 이해하고, 이를 적절히 사용할 수 있게 되는 것이 목표**

---

## 1-1 데이터 타입의 종류
* 기본형 : 숫자, 문자열,불리언,null,undefined 추가로 ES6에서는 심볼이 추가되었다.
* 참조형 : 객체,배열,함수,날짜,정규표현식 추가로 ES6에서는 Map,WeakMap,Set,WeakSet 등이 객체의 하위 분류에 속하여 추가되었다.

### 어떤 기준으로 기본형과 참조형이 구분 되는 것인가?
**기본형**은 값이 담긴 주솟값을 바.로 복제하는 반면
**참조형**은 주솟값들로 이루어진 묶.음.을 가.리.키.는 주.솟.값을 복제한다는 점이다.


## 1-2 데이터 타입에 관한 배경지식

### **1-2-1 메모리와 데이터**
컴퓨터는 모든 데이터를 0과 1로 바꿔 기억한다. 0과1을 각각 조각을 비트(bit)라고 한다.
메모리의 낭비를 최소화하기 위해서 고민끝에 비트의 묶음 바이트가 생겨났고, 8개비트 한 묶음을 1바이트, 16개비트 한 묶음을 2바이트로 만들었다. 

과거에 비해 메모리 공간이 많이 넉넉해져서 이제는 숫자의 경우 정수형인지 부동소수형이지를 구분하지 않고 64비트, 즉 8비티를 확보하게 되었다. 덕분에 형변환을 해야하는 수고로움이 훨씬 적어졌다.

**간단한 정리**
비트는 각 고유한 식별자를 갖는다. 바이트 또한 시작하는 비트의 식별자를 통해 위치 파악이 가능해진다. 그리고 모든 데이터는 바이트 단위의 식별자, 즉 메모리 주솟값을 통해 서로 구분하고 연결할 수 있다.

### 1-2-2 식별자와 변수

**변수** : '변할 수 있는 수' = 변경 가능한 데이터가 담길 수 있는 공간
**식별자** : 어떤 데이터를 식별할 때 사용하는 이름, '변수명'이라고 할 수 있다.

## 1-3 변수 선언과 데이터 할당

### 1-3-1 변수 선언
/선언 동작 방식을 알아보자..!/
/그리고 어떻게 메모리에 저장되는지 알아보자..!/

```javascript
var a ;
a = 'qwe';

var a = 'qwe';
```

우선 기본형타입부터 정리해보자!

1. 우선 '변수a 의 공간을 만들어줘'라는 명령이 들어왔다.
2. 컴퓨터는 메모리에서 비어있는 공간 하나를 마련해준다.
3. 그럼 그 공간의 주소명이 (만약) `1001`이라고 한다면, 주소`1001`에 데이터는 이름,값이 담긴다.
4. 주소`1001` => 이름은 변수명 a이고, 값은 'qwe' 이라고 생각이 들지만 그렇지 않다.

**이름:a 는 맞지만 값에는 데이터 영역의 `@데이터영역 주소`가 들어간다**
**즉, 데이터는 저장하기 위해 별도의 메모리 공간을 다시 확보해서 문자열 'qwe'를 저장하고, 그 주소를 변수영역에 저장하는 식으로 이루워진다.**


## 기본형 데이터와 참조형 데이터

### 1-4-1 불변값
**변수(variable) , 상수(constant)**
변수와 상수를 구분 짓는 변경 가능성의 대상은 '변수영역'메모리이다.
한 번 데이터 할당이 이뤄진 변수 공간에 다른 데이터를 '재할당'할 수 있는지 여부가 관건이다.


**상수와 불변값은 전혀 다르다!**
불변성 여부를 구분할 때의 변경 가능성의 대상은 '데이터 영역'메모리이다.
/기본형 데이터인 숫자,문자열,boolean,null,undefined,symbol은 모두 불변값이다./

```javascript
var b = 'abc';
b = b + 'def';

var b;
// b = 'abcdef'
```

라는 내용에서 보면

1. 변수b 의 메모리 공간을 만들고,
2. 비어있는 (예) 주소`2002`에 이름과 값을 저장한다.
3. 이름은 변수명 b, 값은 abc가 아니고, 이 abc는 데이터 영역의 주소의 값으로 들어간다.
**데이터 영역 : 주소`7010` 안에 'abc'**
4. 변수 영역: 주소 `2002`, 이름:b , 값:@7010
5. 뒤에 추가로 'def'가 추가되면 데이터 영역이 주소가 바뀐다. 즉, 새롭게 만들어진다.
6. 데이터 영역 : 주소 `7013` 안에는 'abcdef'
7. 최종적으로는 변수 영역: 주소 `2002`, 이름: b, 값:@7013


```javascript
var c = 4;
var d = 4;

var d = 5;
```

이런 경우에서는

1. c와 d는 같은 4의 값을 가지고 있을 때는 값은 주소를 가지고 있다.
2. 하지만 d가 5로 '재할당'이 되면 데이터 영역에서 5값이 있는지 찾는다.
3. 만약 있으면 d는 5값이 있는 주소를 재활용하고, 없으면 새롭게 만든다.

### 이처럼 한 번 반든 값은 바꿀 수도 없고, 다른 값으로 변경할 수가 없다. 즉 변경이라는 것은 `새로 만드는 동작`을 통해서만 이뤄진다. 이것이 바로 `불변값의 성질`이다. 우리 눈에는 값이 바꼈지만 컴퓨터 안에서는 값이 바뀐 게 아니라 새롭게 값이 만들어져서 그곳으로 옯겨가진 것이고 이전 값이 사라진 게 아니라 다른 곳에 남아있는 것이다.


### 1-4-2 가변값
기본형 데이터는 모두 불변값이라고 했으니 그럼 참조형 데이터는 모두 가변값이라고 생각게 된다.
물론 참조형의 기본적인 성징은 가변값인 경우가 많다. 하지만 설정에 따라 불변값으로 변경이 가능하기도 하다.

우선,

```javascript
var obj = {
    a: 1,
    b: 'bbb'
};
```

참조형 데이터의 할당을 보자면

1. 변수 영역의 빈공간`@1002`을 확보한다. 그 주소 이름을 obj으로 지정한다.
2. 임의의 데이터 저장 공간`@5001`에 데이터를 저장하려고 보니 여려 개의 프로퍼티로 이뤄진 데이터 그룹이다.
3. 이 그룹 내부의 프로퍼티들을 저장하기 위해 별도의 변수 영역을 마련하고(객체`@5001`을 위한 영역) 그 영역의 주소(`@7103 ~ ?` 물음표는 안의 객체 데이터가 공간을 얼마만큼 차지할지 몰라서 일단 임의로 공간을 차지하기 때문에 ?가 나온 것)를 `@5001`에 저장한다.
4. `@7103` , `@7014`에 각각 a,b라는 프로퍼티 이름을 지정한다.
5. 데이터 영역에 1를 검색하면 검색 결과가 없음으로 임의로 `@5003`에 저장하고, 이 주소를 `@7103`에 저장한다.
6. 문자열 'bbb'도 임의로 `@5004`에 저장하고 이 주소를 `@7104`에 저장한다.


**기본형 데이터와의 차이는 '객체의 변수(프로퍼티) 영역'이 별도로 존재한다는 점이다.**
**데이터 영역에 저장된 값은 모두 불.변.값이다. 그러나 변수에는 다른 값을 얼마든지 대입할 수 있다. 바로 이부분 때문에 참조형 데이터는 불변하지 않다(가변값)라고 하는 것이다.**

예제로 확인해보자!

```javascript
var obj = {
    a: 1,
    b: 'bbb'
};

obj.a = 2;
```

이렇게 객체 안의 a의 값을 재할당 한다면,
1. 데이터 영역에서 숫자 2를 검색한다.
2. 검색 결과가 없으면 메모리 빈공간에 (만약) `@5005`에 저장하고 값은 데이터 영역 주소 `@7015`에 저장한다.
3. 변수 obj이 바라보고 있는 주소 `@5001`은 바뀌지 않고 즉, **새로운 객체가 만들어진 것이 아니라 객체 내부 값만 바뀐 것이다.**


재할당이 되면서 주소가 새로 생겨나기도 하고 한 주소에 여려 변수가 같은 주소를 가르키기도 한다.
어떤 데이터에 대해 자신의 주소를 참조하는 변수의 개수를 `참조 카운트`라고 한다.

만약 참조 카운트가 '0'이 된다면 이 주소는 그저 자리만 차지하고 있는 것이 된다. 이렇게 불필요한 자리 차지를 정리하기 위해서 있는 것이 **가비지 컬렉터(garbage collector)**라고 한다.
가비지 컬렉터는 런타임 환경에 따라 특정 시점이나 메모리 사용량이 포화 상태에 임박할 때마다 자동적으로 수거 대상 즉, 참조 카운트 = 0인 대상들을 수거하여 **다시 새로운 값을 할당할 수 있는 빈 공간을 만들어준다.**


