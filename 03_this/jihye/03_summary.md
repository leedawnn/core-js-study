# 03_this

## 01 상황에 따라 달라지는 this
자바스크립트에서 this는 기본적으로 실행 컨텍스트가 생성될 때 함께 결정된다. 실행 컨텍스트는 함수를 호출할 때 생성되므로, 바궈 말하면 this는 **함수를 호출할 때 결정된다**고 할 수 있다. 함수를 어떤 방식으로 호출하느냐에 따라 값이 달라지는 것이다. 

### 3-1-1 전역 공간에서의 this
전역 공간에서 this는 전역 객체를 가리킨다. 개념상 전역 컨텍스트를 생성하는 주체가 바로 전역 객체이기 때문이다. 전역 객체는 자바스크립트 런타임 환경에 다라 다른 이름과 정보를 가지고 있다. 브라우저 환경에서 전역객체는 window이고 Node.js 환경에서는 global입니다.

**전역 공간에서만 발생하는 특이한 성질(this와는 상관 없음)**
전역변수를 선언하면 자바스크립트 엔진은 이를 전역객체의 프로퍼티로도 할당한다. 변수이면서 객체의 프로퍼티이기도 한 셈이다. 참고로 3번째 줄의 window를 global로 바꾸면 Node.js환경에서도 같은 동작을 확인할 수 있다. 
```
var a = 1;
console.log(a);         //1         
console.log(window.a);  //1
console.log(this.a);    //1
```
전역공간에서 선언한 변수 a에 1을 할당했을 뿐인데 window.a와 this.a 모두 1이 출력된다. 전역공간에서의 this는 전역객체를 의미하므로 두 값이 같은 값을 출력하는 것은 당연하다. 그 이유는 **자바스크립트의 모든 변수는 실은 특정 객체의 프로퍼티**로서 동작하기 때문이다. 사용자가 var 연산자를 이용해 변수를 선언하더라도 실제 자바스크립트 엔진은 특정 객체의 프로퍼티로 인식하는 것이다. 특정 객체란 바로 실행 컨텍스트의 LexicalEnvironment이다. 실행 컨텍스트는 변수를 수집해서 L.E의 프로퍼티로 저장한다. 이후 어떤 변수를 호출하면 L.E를 조회해서 일치하는 프로퍼티가 있을 경우 그값을 반환한다. 전역 컨텍스트의 경우 L.E는 전역객체를 그대로 참조한다. 

따라서 앞에서 '전역변수를 선언하면 자동으로 전역객체의 프로퍼티로 할당한다'고 했는데, 이 문장은 틀렸다. 정확히 표현하면 **'전역변수를 선언하면 자바스크립트 엔진은 이를 전역객체의 프로퍼티로 할당한다'**가 된다. 

### 3-1-2 메서드로서 호출할 때 그 메서드 내부에서의 this

#### 함수 vs. 메서드
함수를 실행하는 방법들 중 가장 일반적인 방법 두 가지는 함수로서 호출하는 경우와 메서드로서 호출하는 경우다. 함수와 메서드는 미리 정의한 동작을 수행하는 코드 뭉치로, 이 둘을 구분하는 유일한 차이는 **독립성**에 있다. 함수는 그 자체로 독립적인 기능을 수행하는 반면, 메서드는 자신을 호출한 대상 객체에 관한 동작을 수행한다. 자바스크립트는 상황별로 this 키워드에 다른 값을 부여하게 함으로써 이를 구현했다. 어떤 함수를 객체의 프로퍼티에 할당한다고 해서 그 자체로서 무조건 메서드가 되는 것이 아니라 객체의 메서드로서 호출할 경우에만 메서드로 동작하고, 그렇지 않으며 함수로 동작한다. 

그렇다면 '함수로서의 호출'과 '메서드로서의 호출'을 어떻게 구분할까?
힘스 앞에 점(.)이 있는지 여부반으로 간단하게 구분할 수 있다. 
```
func(1);            // 앞에 점이 없으니 함수로서 호출
obj.method(2);      // 점이 있으니 메서드로서 호출
```
다시 말해 어떤 함수를 호출할 때 그 함수 이름(프로퍼티명)앞에 객체가 명시돼 있는 경우에는 메서드로 호출한 것이고, 그렇지 않은 모든 경우에는 함수로 호출한 것이다.

#### 메서드 내부에서의 this
this에는 호출한 주제에 대한 정보가 담긴다. 어떤 함수를 메서드로서 호출하는 경우 호출 주체는 바로 함수명(프로퍼티명) 앞의 객체이다. 

### 3-1-3 함수로서 호출할 때 그 함수 내부에서의 this
#### 함수 내부에서의 this
어떤 함수를 함수로서 호출할 경우에는 this가 지정되지 않는다. 함수로서 호출하는 것은 호출 주체를 명시하지 않고 개발자가 코드에 직접 관여해서 실행한 것이기 때문에 호출 주체의 정보를 알 수 없다. 2장에서 실행 컨텍스트를 활성화할 당시에 this가 지정되지 않은 경우 this는 전역 객체를 바라본다고 했다. 따라서 함수에서의 this는 전역 객체를 가리킨다. 더글라스 크락포드는 이를 명백한 설계상의 오류라고 지적했다.

#### 메서드 내부함수에서의 this
앞서 소개한 '설계상의 오류'로 인해 실제 동작과 다르게 예측되곤 한다. 내부함수 역시 이를 함수로서 호출했는지 메서드로서 호출했는지만 파악하면 this의 값을 맞출 수 있다. 

그러니 결국은 this 바인딩에 관해서는 함수를 실행하는 당시의 주변환경(메서드 내부인지, 함수 내부인지 등)은 중요하지 않고, 오직 해당 함수를 호출하는 구문 앞에 점 또는 대괄호 표기가 있는지 없는지가 관건이다.

#### 메서드 내부 함수에서의 this를 우회하는 방법
호출 주체가 없을 때는 자동으로 전역객체를 바인딩하지 않고 호출 당시 주변 환경의 this를 그대로 상속받아 사용할 수 있다면 좋겠다. 이러한 방식이 자연스럽고 스코프 체인과의 일관성을 지키는 설득력있는 방식이다. 변수를 검색하면 우선 가장 가까운 스코프의 L.E를 찾고 없으면 상위 스코프를 탐색하듯이, this 역시 현재 컨텍스트에 바인딩된 대상이 없으면 직전 컨텍스트의 this를 바라보도록 말이다.

아쉽게도 ES5까지는 자체적으로 내부함수에 this를 상속할 방법이 없지만 다행히 이를 우회할 방법이 없지는 않다. 그중 대표적인 방법은 바로 변수를 활용하는 것이다. 

```
var obj = {
    outer: function () {
        console.log(this);                  // (1) { outer: f }
        var innerFunc1 = function () {      // (2) window { ... }
            console.log(this);
        };
    };
    innerFunc1();

    var self = this;
    var innerFunc2 = function () {
        console.log(self);                  // (3) { outer: f }
    };
    innerFunc2();
};
obj.outer();
```
innerFunc1 내부에서 this는 전역객체를 가리킨다. 한편 outer 스코프에서 self라는 변수에 this를 저장한 상태에서 호출한 innerFunc2의 경우 self에는 객체 obj가 출력된다. 우회라고 할 수도 없을 만큼 허무한 방법이지만 기대에는 부합한다. 

#### this를 바인딩하지 않는 함수
ES6에서는 함수 내부에서 this가 전역객체를 바라보는 문제를 보완하고자, this를 바인딩하지 않는 화살표 함수를 새로 도입했다. 화살표 함수는 실행 컨텍스트를 생성할 때 this 바인딩 과정 자체가 빠지게 되어, 상위 스코프의 this를 그대로 활용할 수 있다. 

### 3-1-4 콜백 함수 호출 시 그 함수 내부에서의 this
함수 A의 제어권을 다른 함수(또는 메서드) B에게 넘겨주는 경우 함수 A를 콜백 함수라 한다. 이때 함수 A는 함수 B의 내부 로직에 따라 실행되며, this 역시 함수 B 내부 로직에서 정한 규칙에 따라 값이 결정된다. 콜백 함수도 함수이기 때문에 마찬가지로 this가 전역객체를 참조하지만, 제어권을 받은 함수에서 콜백 함수에 별도로 this가 될 대상을 지정한 경우에는 그 대상을 참조한다.

- 콜백 함수에서의 this는 무조건 무엇이라고 정의 불가능
- 콜백 함수의 제어권을 가지는 함수(메서드)가 콜백 함수에서의 this를 무엇으로 할지를 결정
- 특별히 this를 정의하지 않은 경우엔 기본적으로 함수와 마찬가지로 전역객체를 바라본다.

### 3-1-5 생성자 함수 내부에서의 this
**생성자 함수란?** : 어떤 공통된 성질을 지니는 객체들을 생성하는 데 사용하는 함수.
객체지향 언어에서는 생성자를 클래스, 클래스를 통해 만든 객체를 인스턴스라 한다.

- 프로그래밍적으로 생성자는 **구체적인 인스턴스를 만들기 위한 일종의 틀**(붕어빵틀)
- 인스턴스는 생성자의 공통 속성 + 구체적 인스턴스의 개성(팥붕인가? 슈붕인가?)을 더해 만들어진 것.

자바스크립트는 함수에 생성자로서의 역할을 함께 부여했다. new 명령어와 함께 함수를 호출하면 해당 함수가 생성자로서 동작한다. 그리고 어떤 함수가 생성자 함수로서 호출된 경우 내부에서의 this는 곧 새로 만들 구체적인 인스턴스 자신이 된다.  

## 02 명시적으로 this를 바인딩하는 방법
---------------------------------------------------------------------
### 3-2-1 call 메서드
```
Function.prototype.call(thisArg[, arg1[, arg2[, ...]]])
```
호출 주체인 함수를 즉시 실행하도록 하는 명령

### 3-2-2 apply 메서드
```
Function.prototype.apply(thisArg[, argsArray])
```
apply 메서드는 call 메서드와 기능적으로 동일,
첫 번째 인자를 제외한 나머지 모든 인지들을 호출할 함수의 매개변수로 지정하는 call 메서드와 달리, apply 메서드는 두 번째 인자를 배열로 받아 그 배열의 요소들을 호출할 함수의 매개변수로 지정한다는 차이가 있다.

### 3-2-3 call/apply 메서드의 활용

#### 유사배열객체(array-like object)에 배열 메서드를 적용
- 객체에는 배열 메서드를 직접 적용할 수 없다. 
- 그러나 **키가 0 또는 양의 정수인 프로퍼티가 존재**하고 length **프로퍼티의 값이 0 또는 양의 정수**인 객체, 즉 배열의 구조와 유사한 객체의 경우(유사배열객체) call 또는 apply 메서드를 이용해 배열 메서드를 차용 가능하다.
- slice 메서드에 매개변수를 넘기지 않으면 그냥 원본 배열을 얕은 복사한다.
- 단, 문자열의 경우 원본 문자열에 변경을 가하는 메서드는 에러를 던진다.
- concat처럼 대상이 반드시 배열이어야 하는 경우에는 에러는 나지 않지만, 제대로 된 결과를 얻을 수 없다.

#### 생성자 내부에서 다른 생성자를 호출
- 생성자 내부에 다른 생성자와 공통 내용이 있을 경우, call이나 apply를 사용해 다른 생성자 호출시 반복을 줄일 수 있다.

#### 여러 인수를 묶어 하나의 배열로 전달하고 싶을 때 - apply 활용
- call/apply 메서드는 명시적으로 별도의 this를 바인딩하면서 함수 또는 메서드를 실행하는 훌륭한 방법이지만..
- 오히려 이로 인해 this를 예측하기 어려워 코드 해석을 방해
- 그럼에도 ES5 이하의 환경에서는 실무에서 광범위하게 활용

### 3-2-4 bind 메서드
```
Function.prototype.bind(thisArg[, arg1[, arg2[, ...]]])
```
- call과 비슷하지만 즉시 호출하진 않고, 넘겨받은 this 및 인수들을 바탕으로 새로운 함수를 반환하기만 하는 메서드
- 함수에 this를 미리 적용하는 것과 부분 적용 함수를 구현하는 두 가지 목적을 모두 지닌 메서드

#### name 프로퍼터
bind 메서드를 적용해 만든 함수의 성질
- name 프로퍼티에 동사 bind의 수동태인 'bound'라는 접두어가 붙는다.
- 따라서 기존의 call이나 apply보다 추적이 용이하다.

#### 상위 컨텍스트의 this를 내부함수나 콜백 함수에 전달하기
- call, apply, bind 메서드를 이용하면 메서드의 this를 그대로 바라보도록 우회가 가능하다.
- 콜백함수를 인자로 받는 함수나 메서드 중에서 기본적으로 콜백 함수 내에서의 this에 관여하는 함수 또는 메서드에 대해서도 bind 메서드 이용시 this를 변경 가능

### 3-2-5 화살표 함수의 예외사항
- ES6에 도입된 화살표 함수는 실행 컨텍스트 생성 시 this를 바인딩하는 과정이 제외됨.
- 함수 내부에 this가 없고, 접근하고자 하면 스코프체인상 가장 가까운 this에 접근
- this를 우회하거나 call/apply/bind를 적용할 필요가 없어 더욱 편리

### 3-2-6 별도의 인자로 this를 받는 경우(콜백 함수 내에서의 this)
콜백 함수를 받는 메서드 중 일부는 추가로 this로 지정할 객체(thisArg)를 인지로 지정할 수 있는 경우가 있다. 

=> 지정시 콜백 함수에서 this 값 변경 가능하며, 이러한 헝태는 **배열 메서드**에 많이 포진
=> 같은 이유로 Set, Map등의 메서드에도 일부 존재

```
var report = {
    sum: 0,
    count: 0,
    add: function () {
        var args = Array.prototype.slice.call(arguments);
        args.forEach(function (entry) {
            this.sum += entry;
            ++this.count;
        }, this);
    },
    average: function () {
        return this.sum / this.count;
    }
};
report.add(60, 85, 95);
console.log(report.sum, report.count, report.average());
```
report 객체에 sum,count 프로퍼티가 있고, add, average 메서드가 있다. 5번째 줄에서 add 메서드는 arguments를 배열로 변환해서 args 변수에 담고, 6번째 줄에서는 이 배열을 순회하며 콜백 함수를 실행한다. 이때 콜백 함수 내부에서의 this는 forEach 함수의 두 번째 인자로 전달해준 this가 바인딩된다. 밑에서 두번째 줄에서 60, 85, 95를 인자로 삼아 add 메서드를 호출하면 이 세 인자를 배열로 만들어 forEach 메서드가 실행된다. 콜백 함수 내부에서의 this는 add 메서드에서의 this가 전달된 상태이므로 add 메서드의 this(report)를 그래로 가리키고 있다. 따라서 배열의 세 요소를 순회하며 report.sum 값 및 report.count 값이 차례로 바뀌고, 순회를 마친 결과 report.sum에는 240이, report.count에는 3이 담기게 된다.

## 03 정리
명시적 this 바인딩이 없는 한 늘 성립하는 규칙
- 전역공간에서의 this는 전역객체(브라우저에서는 window,Node.js에서는 global)를 참조한다.
- 어떤 함수를 메서드로서 호출한 경우 this는 메서드 호출 주체(메서드명 앞의 객체)를 참조한다.
- 어떤 함수를 함수로서 호출한 경우 this는 전역객체를 참조한다. 메서드의 내부함수에서도 같다.
- 콜백 함수 내부에서의 this는 해당 콜백 함수의 제어권을 넘겨받은 함수가 정의한 바에 따르며, 정의하지 않은 경우에는 전역객체를 참조한다.
- 생성자 함수에서의 this는 생성될 인스턴스를 참조한다.

명시적 this 바인딩인 경우
- call.apply 메서드는 this를 명시적으로 짖어하면서 함수 또는 메서드를 호출한다.
- bind 메서드는 this 및 함수에 넘길 인수를 일부 지정해서 새로운 함수를 만든다.
- 요소를 순회하면서 콜백 함수를 반복 호출하는 내용의 일부 메서드는 별도의 인자로 this를 받기도 한다. 