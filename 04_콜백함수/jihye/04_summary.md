# 04 콜백 함수

## 01 콜백 함수란?
함수를 정해진 타이밍에 호출하는 함수. 어떤 타이밍에 호출 명령을 내릴지에 대한 **제어권**과 관련이 깊다.

callback은 `'되돌아 호출해달라'`는 의미이다. 즉, 어떤 함수 X를 호출하면서 '특정 조건일 때 함수 Y를 실행해서 나에게 알려달라'는 요청을 함께 보내는 것이다. 

이처럼 콜백 함수는 다른 코드(함수 또는 메서드)에게 인자로 넘겨줌으로써 그 제어권도 함께 위임한 함수이다. 콜백 함수를 위임받은 코드는 자체적인 내부 로직에 의해 이 콜백 함수를 `적절한 시점에 실행`할 것이다.

## 02 제어권

### 4-2-1 호출 시점
```
var count = 0;
var timer = setInterval(function () {
    console.log(count);
    if (++count > 4) clearInterval(timer);
}, 300);
```
1번째 줄에서 count 변수를 선언하고 0을 할당했다. 2번째 줄에서 timer 변수를 선언하고 여기에 setInterval을 실행한 결과를 할당했다. (호출시 두 개의 매개변수 중 첫 번째는 익명함수이고 두 번째는 300이라는 숫자이다.)

**setInterval()이란?**

setInterval() 함수는 `어떤 코드를 일정한 시간 간격을 두고 반복해서 실행하고 싶을 때 사용`한다. 예를 들면 웹페이지의 특정 부분을 주기적으로 업데이트해줘야 하거나, 어떤 API로부터 변경된 데이터를 주기적으로 받아와야 하는 경우에 사용할 수 있다. setInterval의 구조를 살펴보면 다음과 같다.

```
var intervalID = scope.setInterval(fuc, delay[, param1, param2, ...]);
```
scope에는 Window 객체 또는 Worker의 인스턴스가 들어올 수 있다. 두 객체 모두 setInterval 메서드를 제공하기 때문인데, 일반적인 브라우저 환경에서는 window를 생략하고 함수처럼 이용할 것이다. `매개변수로 func, delay 값은 반드시 전달`해야하며, 세 번째 매개변수부터는 선택적이다. func은 함수이고, delay는 밀리초(ms) 단위의 숫자이며, 나머지는 func함수를 실행할 때 매개변수로 전달할 인자이다. func에 넘겨준 함수는 매 delay(ms)마다 실행되며, 그 결과 어떠한 값도 리턴하지 않는다. setInterval를 실행하면 반복적으로 실행되는 내용 자체를 특정할 수 있는 고유한 ID값이 반환된다. 이를 변수에 담는 이유는 반복 실행하는 중간에 종료(clearInterval)할 수 있게 하기 위함이다.

콜백 함수 예제
```
var count = 0;
var cbFunc = function() {
    console.log(count);
    if(++count > 4) clearInterval(timer);
};
var timer = setInterval(cbFunc, 300);

    // -- 실행 결과 --
    // 0    (0.3초)
    // 1    (0.6초)
    // 2    (0.9초)
    // 3    (1.2초)
    // 4    (1.5초)
```
timer 변수에는 setInterval의 ID값이 담긴다. `첫 번째 인자인 cbFunc 함수(이 함수가 곧 콜백함수)는 0.3초마다 자동으로 실행`될 것이다. 콜백 함수 내부에서는 count 값을 출력하고, count를 1만큼 증가시킨 다음, 그 값이 4보다 크면 반복 실행을 종료하라고 한다. 

코드실행 방식과 제어권
```
code                        |   호출주체             |       제어권             
cbFunc();                   |    사용자             |       사용자  
setInterval(cbFunc, 300);   |    setInterval()    |       setInterval
```
위의 코드를 실행하면 콘솔창에는 0.3초에 한 번씩 숫자가 0부터 1까지 증가하며 출력되다 4가 출력된 이후 종료된다. '다른 코드'에 첫 번째 인자로서 cbFunc를 넘겨주자 `제어권을 넘겨받은 setInterval`이 스스로의 판단에 따라 `적절한 시점에(0.3초마다) 이 익명 함수를 실행`했다. 이처럼 콜백 함수의 제어권을 넘겨받은 코드는 콜백 함수 호출 시점에 대한 제어권을 가진다.

### 4-2-1 인자

콜백 함수 예제 Array.prototype.map
```
var newArr = [10, 20, 30].map(function (currentValue, index) {
    console.log(currentValue, index);
    return currentValue + 5;
});
console.log(newArr);

    // -- 실행 결과 --
    // 10 0
    // 20 1
    // 30 2
    // [15, 25, 35]
```
1번째 줄에서 newArr 변수를 선언하고 우항의 결과를 할당했다. 1번째 줄의 우항은 배열 [10, 20, 30]에 map 메서드를 호출하고 있다. 이때 첫 번째 매개변수로 익명함수를 전달한다. 

**map 메서드의 동작원리?**
```
Array.prototype.map(callback[, thisArg])
callback: function(currentValue, index, array)
```
map 메서드는 첫 번째 인자로 callback 함수를 받고, 생략 가능한 두 번째 인자로 콜백 함수 내부에서 this로 인식할 대상을 특정할 수 있다. thisArg를 생략할 경우에는 일반적인 함수와 마찬가지로 전역객체가 바인딩된다. `map 메서드`는 메서드의 대상이 되는 배열의 모든 요소들을 처음부터 끝까지 하나씩 꺼내어 콜백 함수를 반복 호출하고, 함수의 실행 결과들을 모아 새로운 배열을 만든다. 콜백 함수의 첫 번재 인자에는 배열의 요소 중 현재값이, 두 번재 인자에는 현재값의 인덱스가, 세 번째 인자에는 map 메서드의 대상이 되는 배열 자체가 담긴다. 이를 바탕으로 콜백 함수 예제를 다시 한 번 살펴보자. 

배열 [10, 20, 30]의 각 요소를 처음부터 하나씩 꺼내어 콜백 함수를 실행한다. 우선 첫 번째(인덱스 0)에 대한 콜백 함수는 currentValue에 10이, index에는 인덱스 0이 담긴 채 실행될 것이다. 각 값을 출력후 15 (10 + 5)를 반환할 것이다. 같은 방식으로 세 번째에 대한 콜백 함수까지 실행을 마치면, 이제는 [15, 25, 35]라는 새로운 배열이 만들어져서 변수 newArr에 담기고, 이 값이 5번째 줄에서 출력될 것이다.

제이쿼리(jQuery)의 메서드들은 기본적으로 첫 번째 인자에 index가, 두 번째 인자에 currentValue가 온다. 만약 map 메서드를 제이쿼리의 방식처럼 순서를 바꾸어 사용한다면?

```
var newArr2 = [10, 20, 30].map(function (index, currentValue) {
    console.log(index, currentValue);
    return currentValue + 5;
});
console.log(newArr2);
    // -- 실행 결과 --
    // 10 0
    // 20 1
    // 30 2
    // [5, 6, 7]
```
제이쿼리에서 index, currentValue의 순서가 달라졌기 때문에 실행결과는 0 10, 1 20, 2 30 과 같이 출력될 것이라는 예상이 빗나갔다. 사실 저 단어들은 사용자가 명명한 것일 뿐이다. 컴퓨터는 그저 첫 번째, 두 번째 `순서`에 의해서만 각각을 구분하고 인식했기 때문에 위와 같은 결과가 나왔다. 

인자의 이름이 뭐든간에 그냥 순회 중인 배열 중 현재 요소의 값을 배정하는 것이다. 하지만 5번째 줄에서 [5, 6, 7]이라는 전혀 다른 결과가 나온다. currentValue라고 명명한 인자의 위치가 두 번째라서 컴퓨터가 여기에 인덱스 값을 부여했기 때문이다. `(return currentValue + 5이기에 인덱스 값에 0씩 더한 배열이 결과값이 된다.)`

map 메서드를 호출해서 원하는 배열을 얻으려면 map 메서드에 정의된 규칙에 따라 함수를 작성해야 한다. 정의된 규칙에는 콜백 함수의 인자로 넘어올 값들 및 그 순서도 포함되어 있다. 콜백 함수를 호출하는 주체가 사용자가 아닌 map 메서드이므로 map 메서드가 콜백 함수를 호출할 때 인자에 어떤 값들을 어떤 순서로 넘길 것인지가 전적으로 map 메서드에게 달린 것이다. 이처럼 콜백 함수의 제어권을 넘겨받은 코드는 콜백 함수를 호출할 때 인자에 어떤 값들을 어떤 순서로 넘길 것인지에 대한 제어권을 가진다.

### 4-2-3 this
`"콜백 함수도 함수이기 때문에 기본적으로 this가 전역객체를 참조하지만, 제어권을 넘겨받을 코드에서 콜백 함수에 별도로 this가 될 대상을 지정한 경우에는 그 대상을 참조하게 된다."`고 언급한 적이 있었다. 별도의 this를 지정하는 방식 및 제어권에 대한 이해를 높이기 위해 map 메서드를 직접 구현해 봅시다. 

```
Array.prototype.map = function (callback, thisArg) {
    var mappedArr = [];
    for (var i = 0; i< this.length; i++) {
        var mappedValue = callback.call(thisArg || window, this[i], i, this);
        mappedArr[i] = mappedValue
    }
    return mappedValue
}
```
메서드 구현의 핵심은 call/apply 메서드에 있다. this에는 thisArg 값이 있는 경우에는 그 값을, 없을 경우에는 전역객체를 지정하고, 첫 번째 인자에는 메서드의 this가 배열을 가리킬 것이므로 배열의 i번째 요소 값을, 두 번째 인자에는 i 값을, 세 번째 인자에는 배열 자체를 지정해 호출한다. 그 결과가 변수 mappedValue에 담겨 mappedArr의 i번째 인자에 할당된다. 

이제 this에 다른 값이 담기는 이유를 정확히 알 수 있다. 바로 제어권을 넘겨받을 코드에서 call/apply 메서드의 첫 번째 인자에 콜백 함수 내부에서의 this가 될 대상을 명시적으로 바인딩하기 때문이다.

```
setTimeout(function () { console.log(this);}, 300);     // (1) Window {...}

[1, 2, 3, 4, 5].forEach(function (x) {
    console.log(this);                                  // (2) Window {...}
});

document.body.innerHTML += '<button id="a">클릭</button>';
document.body.querySelector('#a')
    .addEventListener('click', function (e) {
        console.log(this, e);                          // (3) <button id="a">클릭</button>
    }                                                  // MouseEvent { isTrusted: true, ...}
);
```
(1) setTimeout은 내부에서 콜백 함수를 호출할 때 call 메서드의 첫 번째 인자에 전역객체를 넘기기 때문에 콜백 함수 내부에서의 this가 전역객체를 가리킨다.
(2) forEach는 별도의 인자로 this를 넘겨주지 않았기 때문에 전역객체를 가리키게 된다.
(3) addEventListener는 내부에서 콜백 함수를 호출할 때 call 메서드의 첫 번째 인자에 addEventListener 메서드의 this를 그대로 넘기도록 정의돼 있기 때문에 콜백 함수 내부에서의 this가 addEventListener를 호출한 주체인 HTML엘리먼트를 가리키게 된다.

## 03 콜백 함수는 함수다
콜백 함수는 함수다. 따라서 콜백 함수로 어떤 객체의 메서드를 전달하더라도 그 메서드는 메서드가 아닌 함수로서 호출된다.
```
var obj = {
    vals: [1, 2, 3]
    logValues: function(v, i) {
        console.log(this, v, i);
    }
};
obj.logValues(1, 2);                // {vals: [1, 2, 3], logValues: f} 1 2
[4, 5, 6].forEach(obj.logValues);   // Window {...} 4 0
```
obj의 객체의 logValues는 메서드로 정의됐다. 7번째 줄에서는 이 메서드의 이름 앞에 점이 있으니 메서드로서 호출한 것이다. 따라서 this는 obj를 가리키고, 인자로 넘어온 1, 2가 출력된다.

8번째 줄에서는 이 메서드를 forEach 함수의 콜백 함수로서 전달했다. 이 함수는 메서드로서 호출할 때가 아닌 한 obj와의 직접적인 연관이 없어진다. forEach에 의해 콜백이 함수로서 호출되고, 별도로 this를 지정하는 인자를 지정하지 않았으므로 함수 내부에서의 this는 전역객체를 바라보게 된다.

그러니까 어떤 함수의 인자에 객체의 메서드를 전달하더라도 이는 결국 메서드가 아닌 함수일 뿐이다. 이 차이를 정확히 이해하는 것이 중요하다.

## 04 콜백 함수 내부의 this에 다른 값 바인딩하기
콜백 함수 내부에서 this가 객체를 바라보게 하고 싶다면 어떻게 해야 할까? 별도의 인자로 this를 받는 함수의 경우에는 여기에 원하는 값을 넘겨주면 되지만 그렇지 않은 경우에는 this의 제어권도 넘겨주게 되므로 사용자가 임의로 값을 바꿀 수 없다. 그래서 전통적으로는 this를 다른 변수에 담아 콜백 함수로 활용할 함수에서는 this 대신 그 변수를 사용하게 하고, 이를 클로저로 만드는 방식이 많이 쓰였다.

처음부터 바라볼 객체를 명시적으로 지정하면 어떤 방법으로도 다른 객체를 바라보게끔 할 수가 없다. 이런 문제점 때문에 콜백 함수 내부의 this에 다른 값을 바인딩하는 전통적인 방법을 불편함에도 불구하고 통용해왔다. 다양한 객체에 재활용할 필요가 없다면 전통적인 방법도 문제가 없다. 

전통적인 방식의 아쉬움을 보완하는 방법으로는 ES5에서 등장한 bind 메서드를 이용하는 방법이다.

```
var obj = {
    name: 'obj1',
    func: function () {
        console.log(this.name);
    }
};
setTimeout(obj1.func.bind(obj1), 1000);

var obj2 = {name: 'obj2'};
setTimeout(obj1.func.bind(obj2), 1500);
```

## 05 콜백 지옥과 비동기 제어
- **콜백지옥이란?**: 콜백 함수를 익명 함수로 전달하는 과정이 반복되어 코드의 들여쓰기 수준이 감당하기 힘들 정도로 깊어지는 현상. 보통 비동기적인 작업 수행시 자주 등장.
- **동기적 코드**: 현재 실행 중인 코드가 완료 후 다음 코드를 실행
- **비동기적 코드**: 현재 실행 중인 코드의 완료 여부와 무관하게 즉시 다음 코드로 넘어감. **별도의 요청, 실행 대기, 보류** 등과 관련된 코드는 비동기적 코드이다. 현대의 자바스크립트는 비동기적인 코드의 비중이 훨씬 높다.

콜백 지옥의 문제인 가독성 저하와 어색함을 동시에 해결하는 가장 간단한 방법은 익명의 콜백 함수를 모두 기명함수로 전환하는 것이다.

그렇지만 코드명을 일일이 따라다녀야 하므로 오히려 헷갈릴 소지가 있기도 하다. `비동기적인 일련의 작업을 동기적으로, 혹은 동기적인 것처럼 보이게끔 처리해주는 장치인 Promise, Generator, async/await 등이 도입되었습니다.`

## 06 정리
- 콜백 함수는 다른 코드에 인자로 넘겨줌으로써 그 제어권도 함께 위임한 함수이다.
- 제어권을 념겨받은 코드는 다음과 같은 제어권을 가진다.
  1) 콜백 함수를 호출하는 시점을 스스로 판단해서 실행한다.
  2) 콜백 함수를 호출할 때 인자로 념겨줄 값들 및 그 순서가 정해져 있다. 이 순서를 따르지 않고 코드를 작성하면 엉뚱한 결과를 얻게 된다.
  3) 콜백 함수의 this가 무엇을 바라보도록 할지가 정해져 있는 경우도 있다. 정하지 않은 경우에는 전역객체를 바라본다. 사용자 임의로 this를 바꾸고 싶은 경우 bind 메서드를 활용하면 된다.


